[{"content":"今年主要用obsidian记录日常笔记，博客更新频率低了很多，不过还是要来一篇年终总结。\n父亲走了 继续跑步 老房子卖了 新房子办了房产证 ","permalink":"http://prime167.github.io/posts/2024-12-27-year-end/","summary":"\u003cp\u003e今年主要用obsidian记录日常笔记，博客更新频率低了很多，不过还是要来一篇年终总结。\u003c/p\u003e","title":"我的2024"},{"content":"今年第一篇也是最后一篇献给数独吧\n本次暂且只记录一些结论及来源\n结论 2x2 的4宫数独，完整盘面总共有 288 种，基本形式有2种, 解开至少需要4个提示 2x3 的6宫数独，完整盘面总共有 28200960 种，基本形式有49种, 解开至少需要8个提示 3x3 的9宫数独，完整盘面总共有 6,670,903,752,021,072,936,960 (6.671×10^21), 基本形式有 5,472,730,538种, 解开至少需要17个提示 上面的种数是指数独盘面填满的所有可能情况, 所有形式都可以通过对基本形式旋转、反射、置换和重新标记等对称性操作后得到。一个完整盘面可以通过挖去某些数字得到一个数独谜题，虽然不同的完整盘面挖去数字后可能得到相同的数独谜题，我想可以做的（有唯一解）3x3的数独题比5,472,730,538多吧？\n即使可以做的数独题目只有365种，我想仍然不会对数独的趣味性有什么损失：给你一个3天之前做的题应该也很少有人记得做过，所以上述结论仅仅是为了满足人类的好奇心的纯数学结论罢了。\n参见 Mathematics of Sudoku facts for kids Mathematics of Sudoku -Wikipedia Mathematics of Sudoku -academic.com The Math Behind Sudoku The 4×4 Case How many possible 2x2 soduku\u0026rsquo;s The Structure of Reduced Sudoku Grids and the Sudoku Symmetry Group There are 5472730538 essentially different Sudoku grids \u0026hellip; and the Sudoku symmetry group Ed Russell and Frazer Jarvis There are 49 essentially different Sudoku 2x3 grids \u0026hellip; and the 2x3 Sudoku symmetry group A291187\tNumber of 2 X n Sudoku grids ((2n) X (2n) grids divided into 2 X n boxes) Number of essentially different Sudoku grids There is no 16-Clue Sudoku: Solving the Sudoku Minimum Number of Clues Problem via Hitting Set Enumeration ","permalink":"http://prime167.github.io/posts/2023-12-28-math-behind-sudoku/","summary":"\u003cp\u003e今年第一篇也是最后一篇献给数独吧\u003c/p\u003e","title":"数独背后的数学"},{"content":"新的基于Chromium的Edge浏览器是不错，可是微软老是往里塞乱七八糟的的东西，好在大部分都可以关闭。今天发现了关闭侧边栏搜索右键菜单的方法\n快捷方式目标后边追加\n1 --disable-features=msSidebarSearchAfterSearchWebFor,msSidebarSearchBeforeSearchWebFor 确定重启即可\n","permalink":"http://prime167.github.io/posts/2022-09-08-hide-msedge-search-sidebar-context-menu/","summary":"新的基于Chromium的Edge浏览器是不错，可是微软老是往里塞乱七八糟的的东西，好在大部分都可以关闭。今天发现了关闭侧边栏搜索右键菜单的方法\n快捷方式目标后边追加\n1 --disable-features=msSidebarSearchAfterSearchWebFor,msSidebarSearchBeforeSearchWebFor 确定重启即可","title":"如何隐藏Edge浏览器的“在侧边栏搜索”菜单"},{"content":"上次说了通过git rebase 合并多个提交，那如何撤销呢？\n先运行git reflog命令查看本地命令记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 ed8a955 (HEAD -\u0026gt; main) HEAD@{0}: rebase (finish): returning to refs/heads/main ed8a955 (HEAD -\u0026gt; main) HEAD@{1}: rebase (squash): 添加用户功能 2776eb0 HEAD@{2}: rebase (squash): # This is a combination of 4 commits. 2aade14 HEAD@{3}: rebase (squash): # This is a combination of 3 commits. ecb64a7 HEAD@{4}: rebase (squash): # This is a combination of 2 commits. 288ebcb HEAD@{5}: rebase (start): checkout HEAD~5 7e7af1b HEAD@{6}: commit: 完成 215353c HEAD@{7}: commit: 修改自测bug 5fcfa4f HEAD@{8}: commit: 完成功能 34024f7 HEAD@{9}: commit: 完成界面设计 288ebcb HEAD@{10}: commit: 开始添加用户功能 b36071d HEAD@{11}: commit: 登录功能 25b848d HEAD@{12}: commit (initial): init 可以看到rebase之前的最后提交 是 7e7af1b HEAD@{6}: commit: 完成\n将本地历史记录reset到此处即可\n1 git reset --hard \u0026#34;HEAD@{6}\u0026#34; 直接使用commit-ish是一个效果\n1 git reset --hard 7e7af ","permalink":"http://prime167.github.io/posts/2022-07-29-undo-git-rebase/","summary":"\u003cp\u003e上次说了通过git rebase 合并多个提交，那如何撤销呢？\u003c/p\u003e","title":"如何撤销一个 git rebase"},{"content":"git的工作区、暂存区、版本库的区分，让我们在编码的时候以渐进的方式稳步的把代码写出来。\n我的习惯是先在工作区和暂存区迭代，某个部分写好了用添加到暂存区，进行下一步；发现工作区太乱了或者这样写不行，可以丢弃工作区的更改。\n工作区达到一定的阶段，就提交一下。整个功能完成后可能是下面这样：\n1 2 3 4 5 6 7 * 7e7af1b - (HEAD -\u0026gt; feat/addUser)完成 * 215353c - 修改自测bug * 5fcfa4f - 完成功能 * 34024f7 - 完成界面设计 * 288ebcb - 开始添加用户功能 * b36071d - (origin/main)登录功能 \u0026lt;----远程 * 25b848d - init 直接合并到main稍显杂乱，先用git rebase把提交合并一下： 要合并的是最后5个提交，使用命令\n1 git rebase -i HEAD~5 git 弹出编辑器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pick 288ebcb 开始添加用户功能 pick 34024f7 完成界面设计 pick 5fcfa4f 完成功能 pick 215353c 修改自测bug pick 7e7af1b 完成 # Rebase b36071d..7e7af1b onto b36071d (5 commands) # # Commands: # p, pick \u0026lt;commit\u0026gt; = use commit # r, reword \u0026lt;commit\u0026gt; = use commit, but edit the commit message # e, edit \u0026lt;commit\u0026gt; = use commit, but stop for amending # s, squash \u0026lt;commit\u0026gt; = use commit, but meld into previous commit # f, fixup [-C | -c] \u0026lt;commit\u0026gt; = like \u0026#34;squash\u0026#34; but keep only the previous # 根据下面的提示，保留第一个(最上面提交)，把后面的提交合并到第一个，下面的pick改成s\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pick 288ebcb 开始添加用户功能 s 34024f7 完成界面设计 s 5fcfa4f 完成功能 s 215353c 修改自测bug s 7e7af1b 完成 # Rebase b36071d..7e7af1b onto b36071d (5 commands) # # Commands: # p, pick \u0026lt;commit\u0026gt; = use commit # r, reword \u0026lt;commit\u0026gt; = use commit, but edit the commit message # e, edit \u0026lt;commit\u0026gt; = use commit, but stop for amending # s, squash \u0026lt;commit\u0026gt; = use commit, but meld into previous commit # f, fixup [-C | -c] \u0026lt;commit\u0026gt; = like \u0026#34;squash\u0026#34; but keep only the previous # 关闭后弹出编辑最终commit message\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # This is a combination of 5 commits. # This is the 1st commit message: 开始添加用户功能 # This is the commit message #2: 完成界面设计 # This is the commit message #3: 完成功能 # This is the commit message #4: 修改自测bug # This is the commit message #5: 完成 # Please enter the commit message for your changes. Lines starting # with \u0026#39;#\u0026#39; will be ignored, and an empty message aborts the commit. # # Date: Fri Jul 29 14:14:06 2022 +0800 改为如下，关闭\n1 2 3 4 5 6 7 8 9 # This is a combination of 5 commits. # This is the 1st commit message: 添加用户功能 # Please enter the commit message for your changes. Lines starting # with \u0026#39;#\u0026#39; will be ignored, and an empty message aborts the commit. # # Date: Fri Jul 29 14:14:06 2022 +0800 提示rebase成功，再次运行git log\n1 2 3 * ed8a955 - 添加用户功能 * b36071d - 登录功能 * 25b848d - init 大功告成，合并到主分支，推送，完美。\n如果功能比较大，我提交了好几十次，那还得一个一个数吗？可以用\n1 git rebase -i [commit-hash] 这里的commit-hash是要合并的所有提交的前一个commit，比如上一个例子里，我要使用\n1 git rebase -i b3706 下面的步骤完全一样，不再赘述。\n","permalink":"http://prime167.github.io/posts/2022-07-29-git-merge-local-commits/","summary":"git的工作区、暂存区、版本库的区分，让我们在编码的时候以渐进的方式稳步的把代码写出来。\n我的习惯是先在工作区和暂存区迭代，某个部分写好了用添加到暂存区，进行下一步；发现工作区太乱了或者这样写不行，可以丢弃工作区的更改。\n工作区达到一定的阶段，就提交一下。整个功能完成后可能是下面这样：\n1 2 3 4 5 6 7 * 7e7af1b - (HEAD -\u0026gt; feat/addUser)完成 * 215353c - 修改自测bug * 5fcfa4f - 完成功能 * 34024f7 - 完成界面设计 * 288ebcb - 开始添加用户功能 * b36071d - (origin/main)登录功能 \u0026lt;----远程 * 25b848d - init 直接合并到main稍显杂乱，先用git rebase把提交合并一下： 要合并的是最后5个提交，使用命令\n1 git rebase -i HEAD~5 git 弹出编辑器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pick 288ebcb 开始添加用户功能 pick 34024f7 完成界面设计 pick 5fcfa4f 完成功能 pick 215353c 修改自测bug pick 7e7af1b 完成 # Rebase b36071d.","title":"如何合并多个git commits"},{"content":"问题 假设一个工程有如下的结构\n\u0026mdash;-Demo sln\n\u0026mdash;\u0026mdash;\u0026ndash;WPF\n\u0026mdash;\u0026mdash;\u0026ndash;DataAccess\nWPF 引用 DataAccess 项目\nDataAccess项目引用nuget包System.Data.SQLite，\n编译后\nDataAccess输出文件夹存在System.Data.SQLite文件和X646和X86，内含SQLite.Interop.dll WPF输出文件夹仅存在System.Data.SQLite文件，需要手动从DataAccess输出文件夹拷贝X646和X86文件夹 而且每次升级System.Data.SQLite nuget包后都需要重新拷贝一次，否则会因为版本不匹配而出现异常。\n解决方法 在DataAccess.csproj 中添加\n1 2 3 4 5 6 \u0026lt;PropertyGroup\u0026gt; \u0026lt;ContentSQLiteInteropFiles\u0026gt;true\u0026lt;/ContentSQLiteInteropFiles\u0026gt; \u0026lt;CopySQLiteInteropFiles\u0026gt;false\u0026lt;/CopySQLiteInteropFiles\u0026gt; \u0026lt;CleanSQLiteInteropFiles\u0026gt;false\u0026lt;/CleanSQLiteInteropFiles\u0026gt; \u0026lt;CollectSQLiteInteropFiles\u0026gt;false\u0026lt;/CollectSQLiteInteropFiles\u0026gt; \u0026lt;/PropertyGroup\u0026gt; 参考 SQLite.Interop.dll files does not copy to project output path when required by referenced project Change nuget build targets to use \u0026lsquo;Content\u0026rsquo; rather than \u0026lsquo;Copy\u0026rsquo; and \u0026lsquo;Delete\u0026rsquo;\n","permalink":"http://prime167.github.io/posts/2022-06-21-msbuild-auto-copy-native/","summary":"问题 假设一个工程有如下的结构\n\u0026mdash;-Demo sln\n\u0026mdash;\u0026mdash;\u0026ndash;WPF\n\u0026mdash;\u0026mdash;\u0026ndash;DataAccess\nWPF 引用 DataAccess 项目\nDataAccess项目引用nuget包System.Data.SQLite，\n编译后\nDataAccess输出文件夹存在System.Data.SQLite文件和X646和X86，内含SQLite.Interop.dll WPF输出文件夹仅存在System.Data.SQLite文件，需要手动从DataAccess输出文件夹拷贝X646和X86文件夹 而且每次升级System.Data.SQLite nuget包后都需要重新拷贝一次，否则会因为版本不匹配而出现异常。\n解决方法 在DataAccess.csproj 中添加\n1 2 3 4 5 6 \u0026lt;PropertyGroup\u0026gt; \u0026lt;ContentSQLiteInteropFiles\u0026gt;true\u0026lt;/ContentSQLiteInteropFiles\u0026gt; \u0026lt;CopySQLiteInteropFiles\u0026gt;false\u0026lt;/CopySQLiteInteropFiles\u0026gt; \u0026lt;CleanSQLiteInteropFiles\u0026gt;false\u0026lt;/CleanSQLiteInteropFiles\u0026gt; \u0026lt;CollectSQLiteInteropFiles\u0026gt;false\u0026lt;/CollectSQLiteInteropFiles\u0026gt; \u0026lt;/PropertyGroup\u0026gt; 参考 SQLite.Interop.dll files does not copy to project output path when required by referenced project Change nuget build targets to use \u0026lsquo;Content\u0026rsquo; rather than \u0026lsquo;Copy\u0026rsquo; and \u0026lsquo;Delete\u0026rsquo;","title":"如何让MsBuild自动拷贝和更新System.Data.SQLite的运行时文件夹X64和X86"},{"content":"缘起 公司电脑升级到Windows 10 21H2后出现了各种问题：\n加密软件每天不定时失效，需要重启电脑才能解决 电脑无法休眠 WinCvs 闪退 Visual Studio 2019 \u0026amp; 2022 拷贝文本经常出现卡死 于是决定重装操作系统。由于之前吃过亏，我是先安装Windows 10 1607，安装加密软件和WinCvs后又升级到21H1，经过几天的使用，没有出现上述的问题，以后就在这一版本养老了。\n备份 1、IP及DNS设置 钉钉聊天记录 C:\\Users\\Administrator\\AppData\\Roaming\\DingTalk 2、微信聊天记录 3、桌面快捷方式 4、环境变量 5、浏览器的UserData 5.1 Edge * AppData\\Local\\Microsoft\\Edge\\User Data * AppData\\Local\\Microsoft\\Edge Beta\\User Data * AppData\\Local\\Microsoft\\Edge Dev\\User Data * AppData\\Local\\Microsoft\\Edge SxS\\User Data 5.2 Google Chrome * AppData\\Local\\Google\\Chrome\\User Data * AppData\\Local\\Google\\Chrome Beta\\User Data * AppData\\Local\\Google\\Chrome dev\\User Data * AppData\\Local\\Google\\Chrome SxS\\User Data Warning 由于Google的安全限制，基于Chromium的浏览器无法做到完全的Portable，重装系统后原来的userdata里的扩展会全部丢失，最好开启同步设置里的同步扩展选项。\n6、浏览器扩展的设置 浏览器的同步扩展功能不会同步扩展的配置，因此需要备份某些扩展的配置\nuBlackOrigin uBlacklist (有Dropbox、Google Drive网盘同步功能) Proxy SwitchyOmega 7、油猴脚本配置 知乎编辑器 Note 暴力猴有云同步功能，可以将所有脚本及配置备份到Dropbox或者Google Drive\n安装软件 调整系统设置 隐藏此电脑下的文件夹 如何隐藏Win10「此电脑」中的「3D对象、视频、图片、文档、下载、音乐、桌面」文件夹\n","permalink":"http://prime167.github.io/posts/2022-04-20_reinstall-os-notes/","summary":"缘起 公司电脑升级到Windows 10 21H2后出现了各种问题：\n加密软件每天不定时失效，需要重启电脑才能解决 电脑无法休眠 WinCvs 闪退 Visual Studio 2019 \u0026amp; 2022 拷贝文本经常出现卡死 于是决定重装操作系统。由于之前吃过亏，我是先安装Windows 10 1607，安装加密软件和WinCvs后又升级到21H1，经过几天的使用，没有出现上述的问题，以后就在这一版本养老了。\n备份 1、IP及DNS设置 钉钉聊天记录 C:\\Users\\Administrator\\AppData\\Roaming\\DingTalk 2、微信聊天记录 3、桌面快捷方式 4、环境变量 5、浏览器的UserData 5.1 Edge * AppData\\Local\\Microsoft\\Edge\\User Data * AppData\\Local\\Microsoft\\Edge Beta\\User Data * AppData\\Local\\Microsoft\\Edge Dev\\User Data * AppData\\Local\\Microsoft\\Edge SxS\\User Data 5.2 Google Chrome * AppData\\Local\\Google\\Chrome\\User Data * AppData\\Local\\Google\\Chrome Beta\\User Data * AppData\\Local\\Google\\Chrome dev\\User Data * AppData\\Local\\Google\\Chrome SxS\\User Data Warning 由于Google的安全限制，基于Chromium的浏览器无法做到完全的Portable，重装系统后原来的userdata里的扩展会全部丢失，最好开启同步设置里的同步扩展选项。\n6、浏览器扩展的设置 浏览器的同步扩展功能不会同步扩展的配置，因此需要备份某些扩展的配置\nuBlackOrigin uBlacklist (有Dropbox、Google Drive网盘同步功能) Proxy SwitchyOmega 7、油猴脚本配置 知乎编辑器 Note 暴力猴有云同步功能，可以将所有脚本及配置备份到Dropbox或者Google Drive","title":"重装操作系统备忘录"},{"content":"上个月操作系统（Windows 10 21H1）无法启动,自动进入戴尔的恢复操作也没能恢复，最后提示分区表丢失，找了个winpe，修复了分区表，进入系统后发现只有操作系统所在的C盘了。下载DiskGenius，搜索分区，找回了丢失的数据分区，最后保存的时候提示此功能需要标准版，付费，保存。\n可是之后系统更新总提示失败，错误0x800f0922。原因在于Windows的 系统恢复分区变成了基本数据分区，可使用下列命令将分区改回EFI分区\n硬盘使用的GPT分区表\n1 2 3 4 5 6 7 管理员运行CMD diskpart list disk sel disk 0 #这里选择你WIN10的系统所在硬盘（EFI分区所在硬盘） list part sel part 1 （选择实际的EFI分区ID，卷标为WINRETOOLS） SET ID=c12a7328-f81f-11d2-ba4b-00a0c93ec93b 之后操作系统就能正常更新了。\n","permalink":"http://prime167.github.io/posts/2021-12-17-fix-win10-update-error-0x800f0922/","summary":"上个月操作系统（Windows 10 21H1）无法启动,自动进入戴尔的恢复操作也没能恢复，最后提示分区表丢失，找了个winpe，修复了分区表，进入系统后发现只有操作系统所在的C盘了。下载DiskGenius，搜索分区，找回了丢失的数据分区，最后保存的时候提示此功能需要标准版，付费，保存。\n可是之后系统更新总提示失败，错误0x800f0922。原因在于Windows的 系统恢复分区变成了基本数据分区，可使用下列命令将分区改回EFI分区\n硬盘使用的GPT分区表\n1 2 3 4 5 6 7 管理员运行CMD diskpart list disk sel disk 0 #这里选择你WIN10的系统所在硬盘（EFI分区所在硬盘） list part sel part 1 （选择实际的EFI分区ID，卷标为WINRETOOLS） SET ID=c12a7328-f81f-11d2-ba4b-00a0c93ec93b 之后操作系统就能正常更新了。","title":"修复Windows 10 更新错误0x800f0922"},{"content":"整理记录一下自己常用的一些软件\n操作系统为 Windows 10 21H2\n开发工具 Visual Studio 2019 Visual Studio 2022 (64位) Visual Studio Code Linqpad (已购买Premium 7.0 版本) BeyondCompare Resharper 版本控制 Fork SourceTree 基于WPF 更新慢 GitExtension 可以创建worktree Git For Windows 控制台 cmder Windows Terminal 远程终端 MobaXterm 用来管理 ubuntu 上的自建 Gitlab 资源管理器增强 Q-dir 多窗格文件资源管理器 Everything 文件搜索 Listary 对话框内自动打开当前窗口 即时搜索 桌面或者文件夹内双击呼出菜单，跳转到预先设置的文件夹 7+ Taskbar Tweaker 任务栏同类项目排序 双击任务栏执行特定动作，如显示桌面 AnyTXT Searcher 基于文件内容的文件搜索 浏览器 Vivaldi 支持纵向标签 Microsoft Chromium Edge Firefox Chrome 基本不用了 浏览器插件 uBlock origin 广告拦截 暴力猴 开源userscript 管理器 MSDN中英文切换 Google Hit Hider by Domain 隐藏内容农场 Pop up blocker for Chrome™ - Poper Blocker 拦截 Medium 类网站弹窗 Lastpass 密码管理 Bitwarden 密码管理，开源，跨平台，已逐步从Lastpass迁移过来 Search Blocklist 隐藏搜索引擎内容农场，比Google Hit Hider by Domain 好用些，规则通用 笔记 印象笔记 (已购买，广告太多，正寻找替代) PDF 阅读 Acrobat Reader DC 虚拟机 Vmware workstation 压缩、解压缩 bandzip 7zip 网站 SharpLab\n非常强大的在线工具：反编译成没有语法糖的C#，反编译位IL，检查堆栈，运行代码，解释C#特性\nRegExr\n正则表达式构建，验证，学习\n","permalink":"http://prime167.github.io/posts/2021-12-15-my-favorite-software-2021/","summary":"\u003cp\u003e整理记录一下自己常用的一些软件\u003c/p\u003e","title":"我常用的软件 (2021版)"},{"content":"VLSM （Variable Length Subnetwork Mask 可变长子网掩码） VLSM(Variable Length Subnet Mask 可变长子网掩码)，这是一种产生不同大小子网的网络分配机制，指一个网络可以配置不同的掩码。开发可变长度子网掩码的想法就是在每个子网上保留足够的主机数的同时，把一个网分成多个子网时有更大的灵活性。如果没有VLSM，一个子网掩码只能提供给一个网络。这样就限制了要求的子网数上的主机数。\nVLSM技术对高效分配IP地址(较少浪费)以及减少路由表大小都起到非常重要的作用。但是需要注意的是使用VLSM时，所采用的路由协议必须能够支持它，这些路由协议包括RIP2，OSPF，EIGRP和BGP。\nCIDR Classless Inter.Domain Routing 无类别域间路由） 1992年引入了CIDR，它意味着在路由表层次的网络地址“类”的概念已经被取消，代之以“网络前缀”的概念。Internet中的CIDR Classless Inter-Domain Routing 无类别域间路由 的基本思想是取消地址的分类结构，取而代之的是允许以可变长分界的方式分配网络数。它支持路由聚合，可限制Internet主干路由器中必要路由信息的增长。IP地址中A类已经分配完毕，B类也已经差不多了 剩下的C类地址已经成为大家瓜分的目标。显然 对于一个国家、地区、组织来说分配到的地址最好是连续的 那么如何来保证这一点呢？于是提出了CIDR的概念。CIDR是Classless Inter Domain Routing的缩写 意为无类别的域间路由。“无类别”的意思是现在的选路决策是基于整个32位IP地址的掩码操作。而不管其IP地址是A类、B类或是C类，都没有什么区别。它的思想是：把许多C类地址合起来作B类地址分配。采用这种分配多个IP地址的方式，使其能够将路由表中的许多表项归并 summarization 成更少的数目。\n区别 CIDR是把几个标准网络合成一个大的网络 VLSM是把一个标准网络分成几个小型网络（子网） CIDR是子网掩码往左边移了，VLSM是子网掩码往右边移了 ","permalink":"http://prime167.github.io/posts/2021-11-04-vlsm-and-cidr/","summary":"VLSM （Variable Length Subnetwork Mask 可变长子网掩码） VLSM(Variable Length Subnet Mask 可变长子网掩码)，这是一种产生不同大小子网的网络分配机制，指一个网络可以配置不同的掩码。开发可变长度子网掩码的想法就是在每个子网上保留足够的主机数的同时，把一个网分成多个子网时有更大的灵活性。如果没有VLSM，一个子网掩码只能提供给一个网络。这样就限制了要求的子网数上的主机数。\nVLSM技术对高效分配IP地址(较少浪费)以及减少路由表大小都起到非常重要的作用。但是需要注意的是使用VLSM时，所采用的路由协议必须能够支持它，这些路由协议包括RIP2，OSPF，EIGRP和BGP。\nCIDR Classless Inter.Domain Routing 无类别域间路由） 1992年引入了CIDR，它意味着在路由表层次的网络地址“类”的概念已经被取消，代之以“网络前缀”的概念。Internet中的CIDR Classless Inter-Domain Routing 无类别域间路由 的基本思想是取消地址的分类结构，取而代之的是允许以可变长分界的方式分配网络数。它支持路由聚合，可限制Internet主干路由器中必要路由信息的增长。IP地址中A类已经分配完毕，B类也已经差不多了 剩下的C类地址已经成为大家瓜分的目标。显然 对于一个国家、地区、组织来说分配到的地址最好是连续的 那么如何来保证这一点呢？于是提出了CIDR的概念。CIDR是Classless Inter Domain Routing的缩写 意为无类别的域间路由。“无类别”的意思是现在的选路决策是基于整个32位IP地址的掩码操作。而不管其IP地址是A类、B类或是C类，都没有什么区别。它的思想是：把许多C类地址合起来作B类地址分配。采用这种分配多个IP地址的方式，使其能够将路由表中的许多表项归并 summarization 成更少的数目。\n区别 CIDR是把几个标准网络合成一个大的网络 VLSM是把一个标准网络分成几个小型网络（子网） CIDR是子网掩码往左边移了，VLSM是子网掩码往右边移了 ","title":"VLSM与CIDR的区别"},{"content":"前几天启动hugo server时提示1313端口被占用，给分配了一个随机端口，打开自己写的程序，mqtt默认的1883端口也被占用，使用\n1 netstat -ano | findstr 1883 没有任何返回 一番Google后得知某些端口被Hyper-V保留了。 解决方法：\n关闭Hyper-V 1 dism.exe /Online /Disable-Feature:Microsoft-Hyper-V 重启后设置你想保留的端口，这样Hyper-V就不能再占用 1 2 # 排除ipv4动态端口占用 startport 起始端口 numberofports 端口数 netsh int ipv4 add excludedportrange protocol=tcp startport=\u0026lt;your port\u0026gt; numberofports=1 对于1313和1883端口，我执行了两次此命令： 1 2 3 netsh int ipv4 add excludedportrange protocol=tcp startport=1313 numberofports=1 netsh int ipv4 add excludedportrange protocol=tcp startport=1883 numberofports=1 重新启用Hyper-V,需要重启 1 dism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All 再次查看端口排除范围（被系统或者我们自己保留的端口）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 λ netsh int ipv4 show excludedportrange tcp 协议 tcp 端口排除范围 开始端口 结束端口 ---------- -------- 80 80 1313 1313 * 1883 1883 * 1899 1998 1999 2098 2108 2207 2208 2307 2308 2407 2422 2521 2522 2621 2622 2721 2722 2821 2822 2921 5357 5357 45000 45000 50000 50059 * * - 管理的端口排除。 带*就是我上面添加的。\n如果要取消保留端口，可以执行\n1 netsh int ipv4 delete excludedportrange protocol=tcp startport=\u0026lt;your port\u0026gt; numberofports=1 ","permalink":"http://prime167.github.io/posts/2021-10-28_windows10-port/","summary":"前几天启动hugo server时提示1313端口被占用，给分配了一个随机端口，打开自己写的程序，mqtt默认的1883端口也被占用，使用\n1 netstat -ano | findstr 1883 没有任何返回 一番Google后得知某些端口被Hyper-V保留了。 解决方法：\n关闭Hyper-V 1 dism.exe /Online /Disable-Feature:Microsoft-Hyper-V 重启后设置你想保留的端口，这样Hyper-V就不能再占用 1 2 # 排除ipv4动态端口占用 startport 起始端口 numberofports 端口数 netsh int ipv4 add excludedportrange protocol=tcp startport=\u0026lt;your port\u0026gt; numberofports=1 对于1313和1883端口，我执行了两次此命令： 1 2 3 netsh int ipv4 add excludedportrange protocol=tcp startport=1313 numberofports=1 netsh int ipv4 add excludedportrange protocol=tcp startport=1883 numberofports=1 重新启用Hyper-V,需要重启 1 dism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All 再次查看端口排除范围（被系统或者我们自己保留的端口）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 λ netsh int ipv4 show excludedportrange tcp 协议 tcp 端口排除范围 开始端口 结束端口 ---------- -------- 80 80 1313 1313 * 1883 1883 * 1899 1998 1999 2098 2108 2207 2208 2307 2308 2407 2422 2521 2522 2621 2622 2721 2722 2821 2822 2921 5357 5357 45000 45000 50000 50059 * * - 管理的端口排除。 带*就是我上面添加的。","title":"Windows 10 解决端口被占用问题"},{"content":"问题 作为开发者，我们会有很多项目，公司项目，开源项目。对于不同的项目，我会使用不同的身份（user.name和user.email组合）：\n公司的项目使用自己的名字和公司的邮箱: 张三 \u0026lt;zhansan@somecorp.com\u0026gt; 开源项目我会使用昵称和私人邮箱: Jack \u0026lt;xxx+xxx@users.noreply.github.com\u0026gt; 在~/.gitconfig（Windows 为%USERPROFILE%.gitconfig）只能声明一组name和email组合作为默认身份。虽然可以在每个repo下简单的通过运行 git config user.email \u0026lt;EMAIL\u0026gt; 和 git config user.name \u0026lt;NAME\u0026gt;命令来更改，问题是对于每个项目我都要运行这两个命令，难免有时候也会忘了设置，导致使用了错误的身份提交。\n幸运的是，git为我们提供解决此问题的方法\n[includeIf] 从 git 2.13.0 开始，git 配置文件开始支持 Conditional Includes 的配置。通过设置 includeIf..path，可以向命中 condition 的 git 仓库引入 path 指向的一个 git 配置文件中配置。\n[includeIf] 的语法如下， 为关键词， 是与关键词关联的数据， 具体意义由关键词决定。\n[includeIf \u0026ldquo;:\u0026rdquo;] path = path/to/gitconfig 其中支持的 keyword 有：\ngitdir: 其中 是一个 glob pattern 如果代码仓库的.git目录匹配 指定的 glob pattern，那么条件命中； gitdir/i：gitdir的大小写不敏感版本。 onbranch：其中 是匹配分支名的一个glob pattern。 假如代码仓库中分支名匹配 ，那么条件命中。 就我们的需求，使用 gitdir 完全可以。\n解决方案 加入我们有以下两个目录\n1 2 |-Work |-Personal 用公司身份提交的项目都存放在work目录，用个人身份提交的项目都存放在personal目录， 在你的~/.gitconfig里，可以使用includeif，根据当前repo的所在目录来加载另一个gitconfig的文件内容：\n1 2 3 4 5 6 7 ... [includeIf \u0026#34;gitdir/i:E:/Work/] path =.gitconfig-work [includeIf \u0026#34;gitdir/i:E:/Personal/\u0026#34;] path =.gitconfig-personal ... .gitconfig-work：\n1 2 3 [user] name = 张三 email = zhangsan@somecorp.com .gitconfig-personal：\n1 2 3 [user] name = Jack email = xxx+xxx@users.noreply.github.com 这样，:E:/Work/下的所有项目都会使用张三这个身份，E:/Personal/下的所有项目则使用Jack这个身份。\n举例 除了公司的工作项目，我目前还使用用GitHub，上面有我一些小的项目和这个托管在GitHub Pages 上的blog，我的配置如下\n1 2 3 4 5 [include] path =.gitconfig-personal [includeIf \u0026#34;gitdir/i:E:/work/git/\u0026#34;] path =.gitconfig-work 这样，把默认身份为个人身份。除了E:/work/git/下的项目用工作身份提交外，其他所有目录的都用个人身份提交。\nGUI 支持 Sourcetree 完美支持 Git Extensions：commit 对话框左下角始终显示默认的用户信息，但是实际签入的时候是调用的底层的系统git，所以能够使用正确的用户签入。 参见：\nAuthor information incorrect when using multiple GitHub accounts (via conditional includes) Support for .gitconfig conditional includes 总结 使用 includeif，可以按照文件夹为不同的组织、公司、项目指定不同的身份，不需要每次都给新的repo指定 user.name 和 user.email。\n参考 Conditional includes\n","permalink":"http://prime167.github.io/posts/2021-10-27-git-commit-user-per-dir/","summary":"问题 作为开发者，我们会有很多项目，公司项目，开源项目。对于不同的项目，我会使用不同的身份（user.name和user.email组合）：\n公司的项目使用自己的名字和公司的邮箱: 张三 \u0026lt;zhansan@somecorp.com\u0026gt; 开源项目我会使用昵称和私人邮箱: Jack \u0026lt;xxx+xxx@users.noreply.github.com\u0026gt; 在~/.gitconfig（Windows 为%USERPROFILE%.gitconfig）只能声明一组name和email组合作为默认身份。虽然可以在每个repo下简单的通过运行 git config user.email \u0026lt;EMAIL\u0026gt; 和 git config user.name \u0026lt;NAME\u0026gt;命令来更改，问题是对于每个项目我都要运行这两个命令，难免有时候也会忘了设置，导致使用了错误的身份提交。\n幸运的是，git为我们提供解决此问题的方法\n[includeIf] 从 git 2.13.0 开始，git 配置文件开始支持 Conditional Includes 的配置。通过设置 includeIf..path，可以向命中 condition 的 git 仓库引入 path 指向的一个 git 配置文件中配置。\n[includeIf] 的语法如下， 为关键词， 是与关键词关联的数据， 具体意义由关键词决定。\n[includeIf \u0026ldquo;:\u0026rdquo;] path = path/to/gitconfig 其中支持的 keyword 有：\ngitdir: 其中 是一个 glob pattern 如果代码仓库的.git目录匹配 指定的 glob pattern，那么条件命中； gitdir/i：gitdir的大小写不敏感版本。 onbranch：其中 是匹配分支名的一个glob pattern。 假如代码仓库中分支名匹配 ，那么条件命中。 就我们的需求，使用 gitdir 完全可以。\n解决方案 加入我们有以下两个目录","title":"git 使用includeIf配置多身份隔离"},{"content":"去年只写了2篇blog，上个月想写的时候发现原始的markdown文件丢失了，幸好再另一台电脑找到了一个比较旧的备份，只有2019年的头几篇。就从发布的html重新写了一遍markdown，更换了maupassant主题，评论使用 utteranc 存储在单独的repo,创建了markdown源文件的repo\n备份太重要了！\n","permalink":"http://prime167.github.io/posts/2021-10-25-blog-reopen/","summary":"去年只写了2篇blog，上个月想写的时候发现原始的markdown文件丢失了，幸好再另一台电脑找到了一个比较旧的备份，只有2019年的头几篇。就从发布的html重新写了一遍markdown，更换了maupassant主题，评论使用 utteranc 存储在单独的repo,创建了markdown源文件的repo\n备份太重要了！","title":"Blog 重新开张"},{"content":"关于解决方案文件sln的说明，官方文档已经说的很清楚的，这里不再重复，只说几个细节的地方\n一个完整的sln文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Microsoft Visual Studio Solution File, Format Version 12.00 # Visual Studio 16 VisualStudioVersion = 16.7.30413.136 MinimumVisualStudioVersion = 10.0.40219.1 Project(\u0026#34;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0026#34;) = \u0026#34;MQTTnetServer\u0026#34;, \u0026#34;MQTTnetServer\\MQTTnetServer.csproj\u0026#34;, \u0026#34;{B0C01277-BBF1-4A23-B700-4E4B6954A3B7}\u0026#34; EndProject Project(\u0026#34;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0026#34;) = \u0026#34;MQTTnetClient\u0026#34;, \u0026#34;MQTTnetClient\\MQTTnetClient.csproj\u0026#34;, \u0026#34;{0CCD1198-FD33-48E7-8B5A-506135EAF0E4}\u0026#34; EndProject Global GlobalSection(SolutionConfigurationPlatforms) = preSolution Debug|Any CPU = Debug|Any CPU Release|Any CPU = Release|Any CPU EndGlobalSection GlobalSection(ProjectConfigurationPlatforms) = postSolution {B0C01277-BBF1-4A23-B700-4E4B6954A3B7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU {B0C01277-BBF1-4A23-B700-4E4B6954A3B7}.Debug|Any CPU.Build.0 = Debug|Any CPU {B0C01277-BBF1-4A23-B700-4E4B6954A3B7}.Release|Any CPU.ActiveCfg = Release|Any CPU {B0C01277-BBF1-4A23-B700-4E4B6954A3B7}.Release|Any CPU.Build.0 = Release|Any CPU {0CCD1198-FD33-48E7-8B5A-506135EAF0E4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU {0CCD1198-FD33-48E7-8B5A-506135EAF0E4}.Debug|Any CPU.Build.0 = Debug|Any CPU {0CCD1198-FD33-48E7-8B5A-506135EAF0E4}.Release|Any CPU.ActiveCfg = Release|Any CPU {0CCD1198-FD33-48E7-8B5A-506135EAF0E4}.Release|Any CPU.Build.0 = Release|Any CPU EndGlobalSection GlobalSection(SolutionProperties) = preSolution HideSolutionNode = FALSE EndGlobalSection GlobalSection(ExtensibilityGlobals) = postSolution SolutionGuid = {4E37268A-53FA-4F12-8CC2-3763A411C11E} EndGlobalSection EndGlobal VisualStudioVersion 的第二位始终是，不会随着版本的升级而改变，也就是在整个Visual Studio 2019 生命周期内，前两位始终是16.0。以下是微软官方的回应：\n$(VisualStudioVersion) is expected to be 16.0 for the full Visual Studio 2019 release cycle. This is somewhat confusing, but it is used to construct paths which have the same property: 16.0 for all Visual Studio 16.x.y\n参考\nSolution (.sln) file Visual Studio build numbers and release dates Visual Studio Release Notes 理解 Visual Studio 解决方案文件格式（.sln） ","permalink":"http://prime167.github.io/posts/2020-06-12-sln-file-notes/","summary":"\u003cp\u003e关于解决方案文件sln的说明，官方文档已经说的很清楚的，这里不再重复，只说几个细节的地方\u003c/p\u003e","title":"Visual Studio 解决方案文件格式拾遗"},{"content":"在未联网的计算机上安装.NET Framework 4.6.1, 4.6.2, 4.7, 4.8 可能会因为缺少根证书失败\n昨天在一台未联网的Windows 7 SP1 上安装 .NET Framework 4.8,报错\n无法建立到信任根颁发机构的证书链\n英文系统下的提示为\nA certificate chain could not be built to a trusted root authority\n意思是我在你的电脑上没有我需要的根证书，我尝试联网下载，但是又连不上。\n解决方法： 最简单的方法就是联网让安装程序自己下载、导入证书（确保能连接 http://ctldl.windowsupdate.com/msdownload/update/v3/static/trustedr/en）。\n如果实在无法联网，就需要下面的步骤了：\n1、下载证书：MicrosoftRootCertificateAuthority2011.cer\n2、安装：\n开始→运行→MMC 文件 → 添加删除管理单元 (Ctrl+M) 证书 → 计算机帐户 -\u0026gt; 本地计算机 展开到：证书 → 受信任的根证书颁发机构 → 证书 右击展开菜单，所有任务 → 导入 选择刚才下载好的MicrosoftRootCertificateAuthority2011.cer，确定 在Windows 7 下离线安装Visual Studio 2019也会遇到证书问题\nhttps://docs.microsoft.com/zh-cn/visualstudio/install/install-certificates-for-visual-studio-offline?view=vs-2019\n","permalink":"http://prime167.github.io/posts/2020-01-15-intall-netfx4.x-offline/","summary":"\u003cp\u003e在未联网的计算机上安装.NET Framework 4.6.1, 4.6.2, 4.7, 4.8 可能会因为缺少根证书失败\u003c/p\u003e","title":"在Windows 7 SP1 下离线安装 .NET Framework 4.8"},{"content":"问题 已知b\u0026gt;a\u0026gt;e(自然对数的底数2.718281828…), 证明a^b\u0026gt;b^a\n从小就对数学和几何有浓厚的兴趣，初中时数学和几何也比较好，结果上了大学高数就歇菜了。\n印象中这应该是我的高考数学题，这些年一直在我的脑海中，今天彻底弄明白。 解题过程：\n要证明a^b\u0026gt;b^a 两边取对数 bln(a) \u0026gt; aln(b) 只需证明ln(a)/a \u0026gt; ln(b)/b 令f(x) = ln(x)/x 求导得f`(x)=(1-lnx)/(x*x) 可以看出f(x)在（0，e）上单调增，在（e,＋∞）上单调减。\n2023 年更新 经常看到的一个问题： 2023的2024次方和2024的2023次方 那个大？\n结论：前者大约是后者的2023/e 倍 约等于 744 倍\n我们来考察一般的(x+1)^x和x^(x+1)哪个大问题\n(x+1)^x/x^(x+1)\n=(x+1))^x/(x^x * x)\n=((x+1)/x)^x / x\n=(1+1/x)^x / x\n根据e的定义\n1 Limit[(1 + 1/x)^x, x -\u0026gt; Infinity] (x+1)^x/x^(x+1) ≈ e/x\n所以\nx^(x+1)/(x+1)^x ≈ x/e\n更一般的情况：\nx^(x+2) 趋近于 (x+2)^x 的 (x/e)^2 倍 x^(x+n) 趋近于 (x+n)^x 的 (x/e)^n 倍 参考 199²⁰⁰和200¹⁹⁹哪个更大?\n","permalink":"http://prime167.github.io/posts/2019-12-31-a-math-inequalit/","summary":"\u003ch2 id=\"问题\"\u003e问题\u003c/h2\u003e\n\u003cp\u003e已知b\u0026gt;a\u0026gt;e(自然对数的底数2.718281828…), 证明a^b\u0026gt;b^a\u003c/p\u003e","title":"一个有趣的不等式的证明"},{"content":"修改NuGet全局缓存路径\nNuget的全局缓存路径默认在\n%userprofile%.nuget\\packages %localappdata%\\NuGet\\v3-cache 随着时间的推移，这个文件夹会占用大量的磁盘。可以通过添加环境变量的方式把它移到其他的盘下： 通过环境变量 添加新变量 NUGET_PACKAGES 值设置为新位置，如 “D:\\NugetCache”\n添加新变量 NUGET_HTTP_CACHE_PATH 值设置为新位置，如 “D:\\NugetHttpCache”\n重启系统后将原文件夹内的内容移到新位置\n修改 %appdata%/nuget下的nuget.config %userprofile%.nuget\\packages 还可以通过修改用户nuget.config实现\n添加 globalPackagesFolder 节点\n1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;config\u0026gt; \u0026lt;add key=\u0026#34;globalPackagesFolder\u0026#34; value=\u0026#34;D:\\NugetCache\u0026#34; /\u0026gt; \u0026lt;/config\u0026gt; \u0026lt;/configuration\u0026gt; 注意 环境变量的优先级较高，二者同时存在的话，前者会覆盖后者。\n参考 Managing the global packages, cache, and temp folders ","permalink":"http://prime167.github.io/posts/2019-12-26-nuget-change-global-cache-dir/","summary":"\u003cp\u003e修改NuGet全局缓存路径\u003c/p\u003e","title":"修改NuGet全局缓存路径"},{"content":"昨天在公司局域网搭建了一个nuget服务器，记录一下过程\n目的 首先，在本地搭建服务器的目的不是在本地复制一个 nuget.org，而是为了解决公司内部常用类库的分发问题。\n目前公用代码主要有两种分发方式：\n传统类库分发方式 源代码方式 在解决方案中直接添加类库的项目文件，再在需要的项目中添加引用\n优点：便于调试\n缺点：需要根据引用路径存放代码。\n类库与使用它的代码通常不在一个源代码版本库里。假设Solution1 以这种方式引用了Lib1，新的开发克隆了Solution1之后打开，Lib1很大可能是不可用状态，打开引用Lib1的项目文件,可能会看到这样的代码：\n1 2 3 4 ... \u0026lt;ItemGroup\u0026gt; \u0026lt;ProjectReference Include=\u0026#34;..\\..\\..\\..\\PC_Shared\\Utils\\PC.Shared.csproj\u0026#34;\u0026gt; ... 新开发必须据此规划路径并克隆Lib1\n以DLL方式分发 Lib1的负责人编译出dll，使用的人放到Solution1下的lib文件夹下，项目中再引用dll。\n优点：部署引用简单\n缺点：版本不易维护\n部署 我选择了官方的Nuget.Server,部署起来非常简单\n新建基于 .NET Framework 的空白 ASP.NET Web 应用程序\n通过NuGet包管理器添加Nuget.Server包\n发布\n部署到IIS\n浏览器中打开，看到下图就表示成功了\n编辑 Web.config\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- Determines if an Api Key is required to push\\delete packages from the server. --\u0026gt; \u0026lt;add key=\u0026#34;requireApiKey\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- Set the value here to allow people to push/delete packages from the server. NOTE: This is a shared key (password) for all users. --\u0026gt; \u0026lt;add key=\u0026#34;apiKey\u0026#34; value=\u0026#34;your api key\u0026#34; /\u0026gt; Visual Studio 添加程序包源 工具 =\u0026gt; 选项 =\u0026gt; NuGet包管理器 =\u0026gt; 程序包源,点击右侧加号添加源\n名称随便写，比如local 源写上一步配置好的地址，如 http://192.168.13.96:9006/nuget 点击确定 测试 随便找个NuGet包，放到IIS路径下的Packages文件夹下，服务器会自动解析包，并生成文件夹结构。 打开包管理器，源选择local，搜索刚才的包名字，是不是出现在搜索结果里了？ 创建NuGet包 目前可以通过3种方式创建一个NuGet包：\n1. 通过NuGet命令行 这种方法适用于传统的基于 .NET Framework的类库\n从 nuget.org 下载最新版本nuget.exe, 放到合适的路径，并添加到 PATH 环境变量\n生成包元数据文件\n在类库.csproj 文件目录下打开命令行，运行\n1 nuget spec ClassLibrary1.csproj 在目录下会生成一个 ClassLibrary1.nuspec，用文本编辑器打开，会看到如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;package\u0026gt; \u0026lt;metadata\u0026gt; \u0026lt;id\u0026gt;$id$\u0026lt;/id\u0026gt; \u0026lt;version\u0026gt;$version$\u0026lt;/version\u0026gt; \u0026lt;title\u0026gt;$title$\u0026lt;/title\u0026gt; \u0026lt;authors\u0026gt;$author$\u0026lt;/authors\u0026gt; \u0026lt;owners\u0026gt;$author$\u0026lt;/owners\u0026gt; \u0026lt;requireLicenseAcceptance\u0026gt;false\u0026lt;/requireLicenseAcceptance\u0026gt; \u0026lt;license type=\u0026#34;expression\u0026#34;\u0026gt;MIT\u0026lt;/license\u0026gt; \u0026lt;projectUrl\u0026gt;http://project_url_here_or_delete_this_line/\u0026lt;/projectUrl\u0026gt; \u0026lt;iconUrl\u0026gt;http://icon_url_here_or_delete_this_line/\u0026lt;/iconUrl\u0026gt; \u0026lt;description\u0026gt;$description$\u0026lt;/description\u0026gt; \u0026lt;releaseNotes\u0026gt;Summary of changes made in this release of the package.\u0026lt;/releaseNotes\u0026gt; \u0026lt;copyright\u0026gt;Copyright 2019\u0026lt;/copyright\u0026gt; \u0026lt;tags\u0026gt;Tag1 Tag2\u0026lt;/tags\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;group targetFramework=\u0026#34;.NETFramework4.8\u0026#34;/\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/metadata\u0026gt; \u0026lt;/package\u0026gt; id 唯一标识 version 版本号(SemVer),如 1.0.0 其他的根据情况填写，$xxx$的为必填项。\n生成NuGet包 在类库.csproj 文件目录下打开命令行，运行\n1 nuget pack 就会生成格式为id.version.nupkg的包了，其实就是一个zip格式的文件，可以添加.zip后缀解压查看。\n2. 使用 dotnet 命令行创建 编辑项目文件 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt; \u0026lt;!--添加以下内容--\u0026gt; \u0026lt;GeneratePackageOnBuild\u0026gt;true\u0026lt;/GeneratePackageOnBuild\u0026gt; \u0026lt;PackageId\u0026gt;myLib2\u0026lt;/PackageId\u0026gt; \u0026lt;Version\u0026gt;1.0.1\u0026lt;/Version\u0026gt; \u0026lt;Authors\u0026gt;your_name\u0026lt;/Authors\u0026gt; \u0026lt;Company\u0026gt;your_company\u0026lt;/Company\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;/Project\u0026gt; 在类库.csproj 文件目录下打开命令行，运行如下命令生成包 1 dotnet pack 3. 使用 Visual Studio 创建 适用于基于.NET Core 或者 .NET Standard 的类库，在项目属性，打包界面填入必须的信息，勾选 “在构建时生成NuGet包” 就会在输出文件夹生成包了。 4.通过 NuGet Package Explorer 创建 和第一种类似，只不过是GUI的方式。\nCreate Package Edit Package Metadata Add Package Content 发布NuGet包 四种方法\nNuGet 命令行\n1 nuget push packagename yourapikey -Source http://192.168.13.96:9006/nuget dotnet 命令行\n1 dotnet nuget push packagename yourapikey -s http://192.168.13.96:9006/nuget NuGet Package Explorer\n如果有权限，当然可以直接把包拷贝到服务器\n设置默认source 老是输入api key和 推送目的地址也是挺繁琐的，可以根据实际情况将配置添加到\n用户级的nuget.config(%appdata%/nuget/nuget.config) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;config\u0026gt; \u0026lt;add key=\u0026#34;defaultPushSource\u0026#34; value=\u0026#34;http://192.168.13.96:9006/nuget\u0026#34; /\u0026gt; \u0026lt;/config\u0026gt; \u0026lt;packageRestore\u0026gt; \u0026lt;add key=\u0026#34;enabled\u0026#34; value=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;add key=\u0026#34;automatic\u0026#34; value=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;/packageRestore\u0026gt; \u0026lt;activePackageSource\u0026gt; \u0026lt;add key=\u0026#34;nuget.org\u0026#34; value=\u0026#34;https://api.nuget.org/v3/index.json\u0026#34; /\u0026gt; \u0026lt;/activePackageSource\u0026gt; \u0026lt;packageSources\u0026gt; \u0026lt;add key=\u0026#34;nuget.org\u0026#34; value=\u0026#34;https://api.nuget.org/v3/index.json\u0026#34; protocolVersion=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;add key=\u0026#34;nuget.org\u0026#34; value=\u0026#34;https://www.nuget.org/api/v2/\u0026#34; /\u0026gt; \u0026lt;add key=\u0026#34;local\u0026#34; value=\u0026#34;http://192.168.13.96:9006/nuget\u0026#34; /\u0026gt; \u0026lt;add key=\u0026#34;Microsoft Visual Studio Offline Packages\u0026#34; value=\u0026#34;C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\\u0026#34; /\u0026gt; \u0026lt;/packageSources\u0026gt; \u0026lt;apikeys\u0026gt; \u0026lt;add key=\u0026#34;http://192.168.13.96:9006/nuget\u0026#34; value=\u0026#34;AQAAANCMnd8BFdERjHoAwE/Cl+sBAAAAZ05kAjZLg06Fp2kByyoGSQAAAAACAAAAAAAQZgAAAAEAACAAAADhe1QaKTEA1JzEKcUxrpKBUV8g0eMEN1qYmkPBex3JPAAAAAAOgAAAAAIAACAAAABVYU2JJIULSVYt7/pIytWRl6CWm6m/QsIyi+x+az8N3BAAAAAUEQGJoa8+exi85xKZcPW6QAAAAKMWHIZoaecy/NA+TfOIc1obyhgtnQVk2rv3RJkAva1D/+w5NrRlUMkzwVRkgSHffEexPPHVNbAnvad7N/HEF1c=\u0026#34; /\u0026gt; \u0026lt;/apikeys\u0026gt; \u0026lt;/configuration\u0026gt; apikey 是加密的，需要通过命令行添加：\n1 2 nuget setapikey yourapikey -source http://192.168.13.96:9006/nuget nuget config -Set DefaultPushSource=http://192.168.13.96:9006/nuget 或者你既维护nuget.org上的公共包，又维护自己公司的私有包，那可以在两个包的解决方案下放不同的nuget.conifg, 里面设置相应的defaultPushSource 和apikey 即可(当前目录为解决方案文件夹) 1 2 3 nuget setapikey yourapikey -source http://192.168.13.96:9006/nuget -configfile nuget.config nuget config -Set DefaultPushSource=http://192.168.13.96:9006/nuget -configfile nuget.config 之后发布包，只需要执行\n1 nuget push packagename 参考 NuGet 官方文档 ","permalink":"http://prime167.github.io/posts/2019-12-24-local-nuget-server/","summary":"\u003cp\u003e昨天在公司局域网搭建了一个nuget服务器，记录一下过程\u003c/p\u003e","title":"局域网搭建私有nuget服务器"},{"content":"很多人Win10 升级到1909后，点击搜索按钮，输入两个字符，搜索界面就消失了，非常不便。下面给出解决这个问题的方法。\n打开日志查看器，有如下错误日志\n1 2 3 4 5 6 7 8 9 10 11 错误应用程序名称: SearchUI.exe，版本: 10.0.18362.418，时间戳: 0x5d995690 错误模块名称: ConstraintIndex.Search.dll，版本: 10.0.18362.207，时间戳: 0x5d0b11a3 异常代码: 0xc0000005 错误偏移量: 0x00000000000b4cb9 错误进程 ID: 0x3a2c 错误应用程序启动时间: 0x01d5b6f59b9c785c 错误应用程序路径: C:\\Windows\\SystemApps\\Microsoft.Windows.Cortana_cw5n1h2txyewy\\SearchUI.exe 错误模块路径: C:\\Windows\\System32\\ConstraintIndex.Search.dll 报告 ID: f1a471d4-1661-4505-9379-6ad5a76cd03e 错误程序包全名: Microsoft.Windows.Cortana_1.13.0.18362_neutral_neutral_cw5n1h2txyewy 错误程序包相对应用程序 ID: CortanaUI 用Unlocker或者火绒的文件粉碎器接触文件夹 :\\Windows\\SystemApps\\Microsoft.Windows.Cortana_ * 的占用, 重命名或者直接删除后再次点击任务栏的搜索按钮，几次后Windows就会重建文件夹，搜索功能就好了。\n","permalink":"http://prime167.github.io/posts/2019-12-23-fix-win10-search/","summary":"\u003cp\u003e很多人Win10 升级到1909后，点击搜索按钮，输入两个字符，搜索界面就消失了，非常不便。下面给出解决这个问题的方法。\u003c/p\u003e","title":"修复Windows 10 搜索功能"},{"content":"双端链表\n定义 双端链表和单链表类似，只不过需要多维护一个指向最后一个节点的指针 Tail，方便从最后插入数据\nC# 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 void Main() { DoubleEndedList list = new DoubleEndedList(); list.InsertHead(2); list.InsertHead(1); list.InsertTail(3); list.InsertTail(4); list.DisplayList(); Console.WriteLine(\u0026#34;======Delete tail======\u0026#34;); list.DeleteTail(); list.DisplayList(); list.DeleteTail(); list.DisplayList(); list.DeleteTail(); list.DisplayList(); list.DeleteTail(); list.DisplayList(); list.DeleteTail(); list.DisplayList(); list.InsertHead(2); list.InsertHead(1); list.InsertTail(3); list.InsertTail(4); list.DisplayList(); Console.WriteLine(\u0026#34;======Delete head======\u0026#34;); list.DeleteHead(); list.DisplayList(); list.DeleteHead(); list.DisplayList(); list.DeleteHead(); list.DisplayList(); list.DeleteHead(); list.DisplayList(); list.DeleteHead(); list.DisplayList(); } public class DoubleEndedList { public Node? Head { get; set; } public Node? Tail { get; set; } public DoubleEndedList() { Head = null; Tail = null; } public bool IsEmpty() { return Head == null; } // 表头插入 public void InsertHead(int dd) { Node newNode = new Node(dd); if (IsEmpty()) { Tail = newNode; } newNode.Next = Head; Head = newNode; } // 表尾插入 public void InsertTail(int dd) { Node newNode = new Node(dd); if (IsEmpty()) { Head = newNode; } else { Tail.Next = newNode; } Tail = newNode; } // 删除表头 public void DeleteHead() { if (Head == null) { return; } Console.WriteLine($\u0026#34;Delete {Head.Value}\u0026#34;); Head = Head.Next; if (Head == null) { Tail = null; } } // 删除表尾 public void DeleteTail() { if (Tail == null) { return; } if (Head == Tail) { Console.WriteLine($\u0026#34;Delete {Tail.Value}\u0026#34;); Head = null; Tail = null; } else { Node? before = null; Node? current = Head; while (current != Tail) { before = current; current = current.Next; } Tail = before; Tail.Next = null; Console.WriteLine($\u0026#34;Delete {current.Value}\u0026#34;); } } public void DisplayList() { Node? current = Head; if (current == null) { Console.WriteLine(\u0026#34;(Empty)\u0026#34;); return; } while (current != null) { current.DisplayNode(); current = current.Next; } } } public class Node { public Node? Next { get; set; } public int Value { get; set; } public Node(int v) { Value = v; } internal void DisplayNode() { Console.Write(Value); if (Next != null) { Console.Write(\u0026#34;-\u0026gt;\u0026#34;); } else { Console.Write(Environment.NewLine); } } } ","permalink":"http://prime167.github.io/posts/2019-12-16-doubleendedlist/","summary":"\u003cp\u003e双端链表\u003c/p\u003e","title":"双端链表"},{"content":"面向对象基础 继承 多态 封装 .NET 术语 CLR CTS CLS IL .NET 基本概念 值类型 引用类型 接口 类 委托事件 垃圾回收 泛型 协变逆变 ","permalink":"http://prime167.github.io/posts/2019-11-21-dotnet-knowledge/","summary":"面向对象基础 继承 多态 封装 .NET 术语 CLR CTS CLS IL .NET 基本概念 值类型 引用类型 接口 类 委托事件 垃圾回收 泛型 协变逆变 ","title":".NET 知识梳理"},{"content":"最近又开始使用Firefox，速度还是可以的，但要想用起来顺手、顺眼还需要一些配置，在此记录一下\n使用紧凑布局 在标签最右空白处点击右键，点击 “定制…”，将地址栏左右的弹性空白拖到下方 下方工具栏勾选 书签工具栏 下方密度选择紧凑 去掉地址栏右边的pocket图标 地址栏输入 about:config,搜索 pocket，将 extensions.pocket.enabled 改为false\n禁用标签滚动 标签达到一定数量后，只显示一部分标签，左右会出现箭头，类似滚动条 地址栏输入 about:config,将 browser.tabs.tabMinWidth 改为 0\n修改个人配置文件位置 地址栏输入 about:profiles , 创建新的配置文件，关闭Firefox后将 APPDATA%\\Mozilla\\Firefox\\Profiles\\ 内的文件移动到新位置，启动firexfox，新的profile成文默认旧的可以删除了。\n安装扩展 ublock origin bitwarden 暴力猴 Tree Style Tab 显示树状标签 ","permalink":"http://prime167.github.io/posts/2019-10-23-config-firefox/","summary":"\u003cp\u003e最近又开始使用Firefox，速度还是可以的，但要想用起来顺手、顺眼还需要一些配置，在此记录一下\u003c/p\u003e","title":"Firefox 70 配置记录"},{"content":"整理记录一下自己常用的一些软件\n操作系统为 Windows 10 1903\n开发工具 Visual Studio 2019 Visual Studio Code Linqpad (已购买Premium 版本) BeyondCompare Resharper 版本控制 Git For Windows SourceTree 基于WPF 更新慢 GitExtension 可以创建worktree 控制台 cmder 远程终端 MobaXterm 用来管理 ubuntu 上的自建 Gitlab 资源管理器增强 Q-dir 多窗格文件资源管理器 Everything 文件搜索 Listary 对话框内自动打开当前窗口 即时搜索 桌面或者文件夹内双击呼出菜单，跳转到预先设置的文件夹 7+ Taskbar Tweaker 任务栏同类项目排序 双击任务栏执行特定动作，如显示桌面 浏览器 Chrome Microsoft Chromium Edge Vivaldi 支持纵向tab Firefox 浏览器插件 uBlock origin 广告拦截 暴力猴 开源userscript 管理器 MSDN中英文切换 Google Hit Hider by Domain 隐藏内容农场 Pop up blocker for Chrome™ - Poper Blocker 拦截 Medium 类网站弹窗 Lastpass 密码管理 Bitwarden 密码管理，开源，跨平台，已逐步从Lastpass迁移过来 Search Blocklist 隐藏搜索引擎内容农场，比Google Hit Hider by Domain 好用些，规则通用 笔记 印象笔记 (已购买) PDF 阅读 Acrobat Reader DC 虚拟机 Vmware workstation 压缩、解压缩 bandzip 7zip 网站 SharpLab\n非常强大的在线工具：反编译成没有语法糖的C#，反编译位IL，检查堆栈，运行代码，解释C#特性\nRegExr\n正则表达式构建，验证，学习\n","permalink":"http://prime167.github.io/posts/2019-10-17-my-favorite-software-2019/","summary":"\u003cp\u003e整理记录一下自己常用的一些软件\u003c/p\u003e","title":"我常用的软件 (2019版)"},{"content":"协变和逆变的概念存在于许多计算机语言中，本文主要讲C#中的协变和逆变\n概念 先从一段代码开始：\n1 object[] objects = new string[2]; 上面的代码在C#中是合法的，其实这就是协变。 因为string继承自object，所以string是object的子类型，记作 string ≦ object。\n而oject的数组类型Object[]，是由object构造出来的一种新的类型,可以认为是一种构造类型，记f(object)，那么我们可以这么来描述协变和逆变：\n当A ≦ B时,如果有f(A) ≦ f(B),那么f叫做 协变 当A ≦ B时,如果有f(B) ≦ f(A),那么f叫做 逆变 如果上面两种关系都不成立则叫做 不可变。 我觉得知乎问题 应该怎么理解编程语言中的协变逆变？ 的 一个回答 说的比较好：\n逆变和协变描述了具有继承关系的类型，通过类型构造器映射到另一范畴时所具有的继承关系。 保持原继承关系的为协变，继承关系反转的为逆变 。\n数组的协变 如上所述，C#从一开始就支持数组类型的协变，但这不是类型安全的:\n1 2 Animal[] animals = new Goldfish[10]; animals[0] = new Tiger(); // 运行时异常 ArrayTypeMismatchException 因为运行时，objs[]的类型是string[],无法存储int型。所以回抛出异常。这个从Java中抄来的特性，被Eric Lippert 列为C#10大最糟糕特性之首，实践中应避免使用。\n型委托的可变性 C# 2.0 引入了委托的变体支持，用于在 C# 中匹配所有委托的方法签名和委托类型。 这表明不仅可以将具有匹配签名的方法分配给委托，还可以将返回派生程度较大的派生类型的方法分配给委托（协变），或者如果方法所接受参数的派生类型所具有的派生程度小于委托类型指定的程度（逆变），也可将其分配给委托。即 对参数的逆变性和对返回值的协变性\n举例说明：\n定义如下继承关系\n1 2 3 4 5 public class L1 { } public class L2 : L1 { } public class L3 : L2 { } 定义一个委托\n1 public delegate L1 SampleDelegate(L3 t); 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 将签名完全匹配的方法赋值给委托，无需转换 SampleDelegate d1 = RL1PL3; // 将一个返回值的派生程度更大（协变），参数值的派生程度更小（逆变）的方法赋值给委托 SampleDelegate d2 = RL2PL2; // 方法返回值派生程度继续变大，参数值的派生程度继续变小 SampleDelegate dNonGenericConversion1 = RL3PL1; // 一个委托就可以适用于全部返回值、参数组合 // 使代码更通用 SampleDelegate sd1 = RL1PL1; SampleDelegate sd2 = RL1PL2; SampleDelegate sd3 = RL1PL3; SampleDelegate sd4 = RL2PL1; SampleDelegate sd5 = RL2PL2; SampleDelegate sd6 = RL2PL3; SampleDelegate sd7 = RL3PL1; SampleDelegate sd8 = RL3PL2; SampleDelegate sd9 = RL3PL3; 逆变为什么是类型安全的？\n1 2 3 Action\u0026lt;Base\u0026gt; b = (target) =\u0026gt; { Console.WriteLine(target.GetType().Name); }; Action\u0026lt;Derived\u0026gt; d = b; d(new Derived()); 由于 lambda 表达式与其自身所分配到的委托相匹配，因此定义了一个方法，此方法采用一个类型 Base 的参数且没有返回值。 可以将结果委托分配给类型类型 Action 的变量，因为 T 委托的类型参数 Action 是逆变类型参数。 由于 T 指定了一个参数类型，因此该代码是类型安全代码。 在调用类型 Action 的委托（就像它是类型 Action的委托一样）时，其参数必须属于类型 Derived。 始终可以将此实参安全地传递给基础方法，因为该方法的形参属于类型 Base。\n泛型中的可变性 泛型集合 C# 不支持泛型集合。考虑下面的代码:\n1 2 3 4 List\u0026lt;Giraffe\u0026gt; giraffes = new List\u0026lt;Giraffe\u0026gt;(); giraffes.Add(new Giraffe()); //List\u0026lt;Animal\u0026gt; animals = giraffes; // 编译错误 //animals.Add(new Lion()); // Aargh! 如果第3行是合法的，那么第4行也是合法,但animails的实际类型是List，你不可能把Lion添加到里面。\n泛型委托 对于委托\n1 public delegate R SampleGenericDelegate\u0026lt;P, R\u0026gt;(P a); 类似非泛型委托,9种函数组合，一个委托就够了：\n1 2 3 4 5 6 7 8 9 SampleGenericDelegate\u0026lt;L3, L1\u0026gt; dg1 = RL1PL1; SampleGenericDelegate\u0026lt;L3, L1\u0026gt; dg2 = RL1PL2; SampleGenericDelegate\u0026lt;L3, L1\u0026gt; dg3 = RL1PL3; SampleGenericDelegate\u0026lt;L3, L1\u0026gt; dg4 = RL2PL1; SampleGenericDelegate\u0026lt;L3, L1\u0026gt; dg5 = RL2PL2; SampleGenericDelegate\u0026lt;L3, L1\u0026gt; dg6 = RL2PL3; SampleGenericDelegate\u0026lt;L3, L1\u0026gt; dg7 = RL3PL1; SampleGenericDelegate\u0026lt;L3, L1\u0026gt; dg8 = RL3PL2; SampleGenericDelegate\u0026lt;L3, L1\u0026gt; dg9 = RL3PL3; C# 4.0 使用 in 和 out 来限定泛型委托中参数的可变性：\nout： 对于泛型类型参数，out 关键字指定该类型参数是协变的。 可以在泛型接口和委托中使用 out 关键字。 in：对于泛型类型参数，in 关键字指定该类型参数是逆变的。 可以在泛型接口和委托中使用 in 关键字。 1 2 3 4 public delegate TResult SampleGenericDelegate\u0026lt;in TP, out TResult\u0026gt;(TP a); public delegate T SampleGenericDelegate1\u0026lt;out T\u0026gt;(); delegate void Action\u0026lt;in T\u0026gt;(T t); delegate TResult Func\u0026lt;out TResult\u0026gt;(); 泛型接口 .NET framework 4.0 使用 in 和 out 来定义接口的可变性，在这之前都是不可变的。\nin 限定类型参数只能用于参数，即逆变 out 限定类型参数只能用于返回值，即协变 1 2 3 4 5 6 7 8 9 10 11 12 interface IVariant\u0026lt;out R, in A\u0026gt; { // 符合规则. R GetR(); void SetA(A sampleArg); R GetRSetA(A sampleArg); // 不符合规则. // A GetA(); // void SetR(R sampleArg); // A GetASetR(R sampleArg); } 内置的一些接口：\npublic interface IEnumerable\npublic interface IEnumerator\npublic interface IQueryable\npublic interface IGrouping\u0026lt;out TKey,out TElement\u0026gt;\npublic interface IComparable\npublic interface IComparer\npublic interface IEqualityComparer\n举例\n最常见的：\n1 2 3 // 协变 IEnumerable\u0026lt;string\u0026gt; listL3 = new List\u0026lt;string\u0026gt;(); IEnumerable\u0026lt;object\u0026gt; lis = listL3; 方法的参数使用IEnumerable编写更通用的方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Program { public static void PrintFullName(IEnumerable\u0026lt;Person\u0026gt; persons) { } public static void Main() { // 协变 List\u0026lt;Teacher\u0026gt; employees = new List\u0026lt;Teacher\u0026gt;(); PrintFullName(employees); // 协变 List\u0026lt;Student\u0026gt; students = new List\u0026lt;Student\u0026gt;(); PrintFullName(students); } } 因为 IEnumerable 是只读的，无法和List一样添加元素，所以此处是类型安全的。\n实现一个通用的Comparer (来源)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 using System; using System.Collections.Generic; abstract class Shape { public virtual double Area { get { return 0; }} } class Circle : Shape { private double r; public Circle(double radius) { r = radius; } public double Radius { get { return r; }} public override double Area { get { return Math.PI * r * r; }} } class ShapeAreaComparer : System.Collections.Generic.IComparer\u0026lt;Shape\u0026gt; { int IComparer\u0026lt;Shape\u0026gt;.Compare(Shape a, Shape b) { if (a == null) return b == null ? 0 : -1; return b == null ? 1 : a.Area.CompareTo(b.Area); } } class Program { static void Main() { // You can pass ShapeAreaComparer, which implements IComparer\u0026lt;Shape\u0026gt;, // even though the constructor for SortedSet\u0026lt;Circle\u0026gt; expects // IComparer\u0026lt;Circle\u0026gt;, because type parameter T of IComparer\u0026lt;T\u0026gt; is // contravariant. // SortedSet\u0026lt;Circle\u0026gt; 的构造函数需要IComparer\u0026lt;Circle\u0026gt;，但仍然可以传入是实现IComparer\u0026lt;Shape\u0026gt;的ShapeAreaComparer SortedSet\u0026lt;Circle\u0026gt; circlesByArea = new SortedSet\u0026lt;Circle\u0026gt;(new ShapeAreaComparer()) { new Circle(7.2), new Circle(100), null, new Circle(.01) }; foreach (Circle c in circlesByArea) { Console.WriteLine(c == null ? \u0026#34;null\u0026#34; : \u0026#34;Circle with area \u0026#34; + c.Area); } } } /* This code example produces the following output: null Circle with area 0.000314159265358979 Circle with area 162.860163162095 Circle with area 31415.9265358979 */ 注意 协变逆变是针对构造类型的，注意和赋值兼容的区别 协变逆变适用于引用类型，不支持值类型 在 .NET Framework 4 中，Variant 类型参数仅限于泛型接口和泛型委托类型。 代码: https://github.com/prime167/csharp-covariance-contravariance.git\n参考、扩展阅读 泛型中的协变和逆变 Covariance and Contravariance FAQ The theory behind covariance and contravariance in C# 4 Understanding C# Features (8) Covariance and Contravariance Eric Lippert 协变逆变文章 Why does C# use contravariance (not covariance) in input parameters with delegate? C# - 协变、逆变 看完这篇就懂了 COVARIANCE, CONTRAVARIANCE AND WHY CAT LOVERS ARE EVIL ","permalink":"http://prime167.github.io/posts/2019-10-08-covariance-and-contravariance-of-csharp/","summary":"\u003cp\u003e协变和逆变的概念存在于许多计算机语言中，本文主要讲C#中的协变和逆变\u003c/p\u003e","title":"C# 的协变和逆变"},{"content":"今天简单介绍一下 .NET framework中的timer\n概述 目前，.NET Framework中有如下几种 timer：\nSystem.Timers.Timer System.Threading.Timer System.Windows.Forms.Timer System.Windows.Threading.DispatcherTimer System.Web.UI.Timer PeriodicTimer 其中前两个是通用的，即可用于客户端，也可用于服务器；第三个用于winform下，第四个用于WPF下，第五个是传统的Asp.NET Page下的控件\nSystem.Windows.Forms.Timer 先看这个最简单的。这是Winform工具箱里的一默认组件，设置一个时间间隔，每个时间间隔要触发的时间，用Start()方法启动即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public partial class Form1 : Form { private int _count; private readonly Timer _timer = new Timer(); private readonly Label _lblCount = new Label(); public Form1() { InitializeComponent(); Size = new Size(450, 450); Controls.Add(_lblCount); _lblCount.Location = new Point(200, 200); _timer.Interval = 100; _timer.Tick += timer1_Tick; } private void Form1_Load(object sender, EventArgs e) { _timer.Start(); } private void timer1_Tick(object sender, EventArgs e) { _count++; _lblCount.Text = _count.ToString(\u0026#34;0000\u0026#34;); if (_count \u0026gt;= 30) { _timer.Stop(); } } } 当然缺点也很明显：\n运行在UI线程，如果每个间隔的操作耗时较长，就会造成阻塞，表现为界面卡顿，影响用户体验\n精度较低，最低只能到55毫秒\nSystem.Windows.Threading.DispatcherTimer 这个和System.Windows.Forms.Timer类似,不过是WPF下使用的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public partial class MainWindow : Window { private int _count = 0; private readonly DispatcherTimer _timer = new DispatcherTimer(); public MainWindow() { InitializeComponent(); _timer.Interval = TimeSpan.FromMilliseconds(100); _timer.Tick += _timer_Tick; } private void _timer_Tick(object sender, EventArgs e) { _count++; lblCount.Content = _count.ToString(\u0026#34;0000\u0026#34;); if (_count \u0026gt;= 30) { _timer.Stop(); } } private void MainWindow_OnLoaded(object sender, RoutedEventArgs e) { _timer.Start(); } } 缺点：\n运行在UI线程，耗时操作也会造成界面卡顿 精度较低，因为是再Dispatcher队列中运行，受到自身和队列中其他事件的影响，不能保证严格按照interval触发事件\nSystem.Threading.Timer 根据时间间隔在线程池中执行操作 (关于跨线程操作，见上一篇博文)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public partial class Form3 : Form { private int _count; private System.Threading.Timer _timer; private readonly Label _lblCount = new Label(); private readonly SynchronizationContext _context; public Form3() { InitializeComponent(); _lblCount.Text = \u0026#34;0000\u0026#34;; _context = SynchronizationContext.Current ?? new SynchronizationContext(); Size = new Size(450,450); Controls.Add(_lblCount); _lblCount.Location = new Point(200, 200); } private void UpdateCount(object state) { _count++; _context.Send(delegate { _lblCount.Text = _count.ToString(\u0026#34;0000\u0026#34;); }, null); if (_count \u0026gt;= 30) { _timer.Change(Timeout.Infinite, Timeout.Infinite); } } private void Form3_Shown(object sender, EventArgs e) { _timer = new System.Threading.Timer(UpdateCount, null, 1000, 100); } } System.Timers.Timer 通过MSDN文档可以知道，该类继承了System.ComponentModel.Component,并实现了System.ComponentModel.ISupportInitialize结果，所以它也可以被添加到工具箱里\n通过分析源码可以发现，它是对 System.Threading.Timer的包装\n用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public partial class Form2 : Form { private int _count; private readonly System.Timers.Timer _timer = new System.Timers.Timer(); private readonly Label _lblCount = new Label(); public Form2() { InitializeComponent(); Size = new Size(450,450); Controls.Add(_lblCount); _lblCount.Location = new Point(200, 200); _timer.Interval = 100; _timer.SynchronizingObject = this; _timer.Elapsed += _timer_Elapsed; } private void _timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e) { _count++; _lblCount.Text = _count.ToString(\u0026#34;0000\u0026#34;); if (_count \u0026gt;= 30) { _timer.Stop(); } } private void Form1_Load(object sender, EventArgs e) { _timer.Start(); } } 如果设置了SynchronizingObject，则调用该控件的BeginInvoke方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 private void MyTimerCallback(object state) { // System.Threading.Timer will not cancel the work item queued before the timer is stopped. // We don\u0026#39;t want to handle the callback after a timer is stopped. if( state != cookie) { return; } if (!this.autoReset) { enabled = false; } FILE_TIME filetime = new FILE_TIME(); GetSystemTimeAsFileTime(ref filetime); ElapsedEventArgs elapsedEventArgs = new ElapsedEventArgs(filetime.ftTimeLow, filetime.ftTimeHigh); try { // To avoid ---- between remove handler and raising the event ElapsedEventHandler intervalElapsed = this.onIntervalElapsed; if (intervalElapsed != null) { if (this.SynchronizingObject != null \u0026amp;\u0026amp; this.SynchronizingObject.InvokeRequired) this.SynchronizingObject.BeginInvoke(intervalElapsed, new object[]{this, elapsedEventArgs}); else intervalElapsed(this, elapsedEventArgs); } } catch { } } System.Web.UI.Timer 略\n源码\nprime167/DotNetTimers\n","permalink":"http://prime167.github.io/posts/2019-09-23-dotnet-timers/","summary":"\u003cp\u003e今天简单介绍一下 .NET framework中的timer\u003c/p\u003e","title":".NET 中的 timer"},{"content":"本篇讲一下如何编写线程安全的Winform 程序\n有问题的代码 一个很简单的功能，Winform上实时显示当前时间：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public partial class Form1 : Form { private System.Threading.Timer _timer; public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { _timer = new System.Threading.Timer(UpdateTime, null, 0, 20); } private void UpdateTime(object state) { lblTime.Text = DateTime.Now.ToString(\u0026#34;hh:mm:ss\u0026#34;); } } F5 运行，出错了：\n","permalink":"http://prime167.github.io/posts/2019-09-06-dotnet-safe-ui-app/","summary":"\u003cp\u003e本篇讲一下如何编写线程安全的Winform 程序\u003c/p\u003e","title":"编写线程安全的UI程序"},{"content":"今天来说一下C#中传递结构体参数的演化\n我们知道，C#有两种数据类型：值类型 (本文主要讨论结构体) 和引用类型，相应的，传参的时候，也有两种方式：\n按值传递：值类型传递的是变量的副本，在函数里的修改不会影响原值 按引用传递：引用类型传递的是对象的引用，在函数内部的修改会也会反应到原变量，因为两者本来就是同一个对象。 值传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 按值传递参数 public double Calculate(Point3D point1, Point3D point2) { double xDifference = point1.X - point2.X; double yDifference = point1.Y - point2.Y; double zDifference = point1.Z - point2.Z; return Math.Sqrt(xDifference * xDifference + yDifference * yDifference + zDifference * zDifference); } ... struct Point3D { public double X { get; set; } public double Y { get; set; } public double Z { get; set; } public Point3D(double x, double y, double z) { X = x; Y = y; Z = z; } } 值传递会频繁创建结构体的副本，当结构体特别大时，就会对性能造成影响。从C# 1.0开始，我们就可以对值类型添加ref 或者 out，直接传递变量的地址而不创建副本，从而避免了性能损耗。\nref：方法可修改变量 out：方法必须修变量 ref 传递 1 2 3 4 5 6 7 8 9 10 11 12 // ref传递 public double CalculateRef(ref Point3D point1,ref Point3D point2) { double xDifference = point1.X - point2.X; double yDifference = point1.Y - point2.Y; double zDifference = point1.Z - point2.Z; return Math.Sqrt(xDifference * xDifference + yDifference * yDifference + zDifference * zDifference); } // 调用： var r2 = CalculateRef(ref p1,ref p2); IL代码, 注意参数类型是Point3D\u0026amp;，即传递的是地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .method public hidebysig instance float64 CalculateRef ( valuetype Point3D\u0026amp; point1, valuetype Point3D\u0026amp; point2 ) cil managed { // Method begins at RVA 0x215c // Code size 57 (0x39) .maxstack 3 .locals init ( [0] float64, [1] float64 ) IL_0000: ldarg.1 ... } // end of method Program::CalculateRef out 传递 1 2 3 4 5 public double CalculateOut(out Point3D point1) { point1 = new Point3D(2,2,2); return 0; } IL 代码, 除了类型是Point3D\u0026amp;，前面还有[out]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 .method public hidebysig instance float64 CalculateOut ( [out] valuetype Point3D\u0026amp; point1 ) cil managed { // Method begins at RVA 0x21a9 // Code size 48 (0x30) .maxstack 8 IL_0000: ldarg.1 IL_0001: ldc.r8 2 IL_000a: ldc.r8 2 IL_0013: ldc.r8 2 IL_001c: newobj instance void Point3D::.ctor(float64, float64, float64) IL_0021: stobj Point3D IL_0026: ldc.r8 0.0 IL_002f: ret } // end of method Program::CalculateOut 但有时候我们不想让调用者修改我们的变量，ref 和 out 就无能为力了。\nin 传递 作为 ref 和 out 的补充，C# 7.2对in关键字进行了扩展，允许传参时用in关键字修饰，以表明设计意图：变量按照引用方式传递，但是不允许方法对变量进行修改。\n1 2 3 4 5 6 7 8 9 10 11 public double CalculateIn(in Point3D point1,in Point3D point2) { //error CS8332: Cannot assign to a member of variable \u0026#39;in Point3D\u0026#39; because it is a readonly variable //point1.X = 33; double xDifference = point1.X - point2.X; double yDifference = point1.Y - point2.Y; double zDifference = point1.Z - point2.Z; return Math.Sqrt(xDifference * xDifference + yDifference * yDifference + zDifference * zDifference); } 如果试图修改point1.X,会产生编译错误CS8332：不能对 in Piont3D变量的成员赋值，因为它是只读的。 但这里有一个陷阱，我们先看一下编译器生成的C#代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public double CalculateIn([In] [IsReadOnly] ref Point3D point1, [In] [IsReadOnly] ref Point3D point2) { Point3D point3D = point1; double x = point3D.X; point3D = point2; double num = x - point3D.X; point3D = point1; double y = point3D.Y; point3D = point2; double num2 = y - point3D.Y; point3D = point1; double z = point3D.Z; point3D = point2; double num3 = z - point3D.Z; return Math.Sqrt(num * num + num2 * num2 + num3 * num3); } // 调用方，不需要添加in var r4 = CalculateIn(p1,p2); 每个变量都生成了防御性副本(defensive copy)。\nIL代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 .method public hidebysig instance float64 CalculateIn ( [in] valuetype Point3D\u0026amp; point1, [in] valuetype Point3D\u0026amp; point2 ) cil managed { .param [1] .custom instance void [mscorlib]System.Runtime.CompilerServices.IsReadOnlyAttribute::.ctor() = ( 01 00 00 00 ) .param [2] .custom instance void [mscorlib]System.Runtime.CompilerServices.IsReadOnlyAttribute::.ctor() = ( 01 00 00 00 ) // Method begins at RVA 0x21dc // Code size 105 (0x69) .maxstack 3 .locals init ( [0] float64, [1] float64, [2] valuetype Point3D ) IL_0000: ldarg.1 IL_0001: ldobj Point3D IL_0006: stloc.2 IL_0007: ldloca.s 2 IL_0009: call instance float64 Point3D::get_X() IL_000e: ldarg.2 除了和out类似的 [in] valuetype Point3D\u0026amp; ，还添加了 IsReadOnlyAttribute，\nIL_0001: ldobj Point3D 这条语句也表明会生成变量副本。\n解决方法 为了解决in传递可能带来的性能问题，C# 7.2 同时添加了 readonly struct\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public double CalculateReadonlyIn(in ReadonlyPoint3D point1,in ReadonlyPoint3D point2) { double xDifference = point1.X - point2.X; double yDifference = point1.Y - point2.Y; double zDifference = point1.Z - point2.Z; return Math.Sqrt(xDifference * xDifference + yDifference * yDifference + zDifference * zDifference); } readonly struct ReadonlyPoint3D { // 所有字段必须是只读的 public double X { get; } public double Y { get; } public double Z { get; } public ReadonlyPoint3D(double x, double y, double z) { X = x; Y = y; Z = z; } } 编译器生成的代码：\n1 2 3 4 5 6 7 public double CalculateReadonlyIn([In] [IsReadOnly] ref ReadonlyPoint3D point1, [In] [IsReadOnly] ref ReadonlyPoint3D point2) { double num = point1.X - point2.X; double num2 = point1.Y - point2.Y; double num3 = point1.Z - point2.Z; return Math.Sqrt(num * num + num2 * num2 + num3 * num3); } 没有创建防御性副本。\n总结 对于较大的struct，用in关键字进行传递提高性能同时表明方法的意图：引用传递，无法修改传入的值 用in传参时一定要配readonly struct，以避免性能损失。 参考 Write safe and efficient C# code\nAvoiding struct and readonly reference performance pitfalls with ErrorProne.NET\nThe ‘in’-modifier and the readonly structs in C#\n本文所有源码\n","permalink":"http://prime167.github.io/posts/2019-08-16-csharp-struct-parameter/","summary":"\u003cp\u003e今天来说一下C#中传递结构体参数的演化\u003c/p\u003e","title":"c# 传递结构体参数的那些事儿"},{"content":"新博客配置的七七八八了，记录一下过程和未解决问题。\n更新记录 2019/8/7 配置完成 2019/10/18 添加Gitmen评论系统 2019/11/25 添加 .nojekyll 文件解决以“.”开头的tag页面显示404问题 2020/6/16 内容过期提醒 2021/10/25 重写丢失的blog，更换maupassant主题，配置utteranc评论系统 2023/12/29 主题更换为 PaperMod 注册GitHub 这个没什么好说的，输入用户名、密码、邮箱创建账户就可以了。\n创建博客 repo repo 必须设置位public repo 的名字必须是[github用户名].github.io 下载hugo 到hugo的 github releases 页面下载最新版本 解压到某个目录，例如 E:\\Data\\blog\\hugo 将此目录添加到环境变量,方便以后运行。推荐使用 Rapid Environment Editor(RapidEE) 创建blog 在 E:\\Data\\blog 下运行\n1 hugo new site myBlog 会在 E:\\Data\\blog 下生成目录 myBlog\n设置主题 hugo主题网站 有很多网站可选,找打自己喜欢的某个主题，根据Installation提示克隆到myBlog\\themes文件夹，比如我用的是even，就在myblog目录执行\n1 git clone https://github.com/olOwOlo/hugo-theme-even themes\\even 然后将themes\\even\\exampleSite\\config.toml 拷贝到根目录\n基本配置 用notepad++或者vscode打开config.toml,根据注释修改一些必要的设置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 baseURL = \u0026#34;https://xxxxxx.github.io\u0026#34; languageCode = \u0026#34;zh-cn\u0026#34; defaultContentLanguage = \u0026#34;zh-cn\u0026#34; # en / zh-cn / ... (This field determines which i18n file to use) title = \u0026#34;我的博客\u0026#34; preserveTaxonomyNames = true enableRobotsTXT = true enableEmoji = true theme = \u0026#34;even\u0026#34; enableGitInfo = false # use git commit log to generate lastmod record # 可根据 Git 中的提交生成最近更新记录。 # Syntax highlighting by Chroma. NOTE: Don\u0026#39;t enable `highlightInClient` and `chroma` at the same time! pygmentsOptions = \u0026#34;linenos=table\u0026#34; pygmentsCodefences = true pygmentsUseClasses = true pygmentsCodefencesGuessSyntax = true hasCJKLanguage = true # has chinese/japanese/korean ? # 自动检测是否包含 中文\\日文\\韩文 paginate = 5 # 首页每页显示的文章数 disqusShortname = \u0026#34;\u0026#34; # disqus_shortname googleAnalytics = \u0026#34;\u0026#34; # UA-XXXXXXXX-X copyright = \u0026#34;\u0026#34; # default: author.name ↓ # 默认为下面配置的author.name ↓ [author] # essential # 必需 name = \u0026#34;Codest\u0026#34; [sitemap] # essential # 必需 changefreq = \u0026#34;weekly\u0026#34; priority = 0.5 filename = \u0026#34;sitemap.xml\u0026#34; [[menu.main]] # config your menu # 配置目录 name = \u0026#34;主页\u0026#34; weight = 10 identifier = \u0026#34;home\u0026#34; url = \u0026#34;/\u0026#34; [[menu.main]] name = \u0026#34;归档\u0026#34; weight = 20 identifier = \u0026#34;archives\u0026#34; url = \u0026#34;/post/\u0026#34; [[menu.main]] name = \u0026#34;标签\u0026#34; weight = 30 identifier = \u0026#34;tags\u0026#34; url = \u0026#34;/tags/\u0026#34; [[menu.main]] name = \u0026#34;类别\u0026#34; weight = 40 identifier = \u0026#34;categories\u0026#34; url = \u0026#34;/categories/\u0026#34; 配置内容过期提醒 1 2 3 4 [params.outdatedInfoWarning] enable = true hint = 30 # Display hint if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示提醒 warn = 180 # Display warning if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示警告 如果你写的内容具有很强的时效性，可以通过配置此项达到提醒读者的目的 如果正在浏览的某篇文章的更新时间在设置的天数之前，则会以不同的底色显示提醒或警告\n【注意】最后更新于 6月前，文中内容可能已过时，请谨慎使用。\n配置utteranc评论系统 utterances 是一款基于 GitHub issues 的评论工具。 首先创建评论存储库，例如https://github.com/prime167/BlogComment 然后打开https://github.com/apps/utterances，安装utterances到刚才创建的库 config.toml 添加配置\n1 2 3 4 5 [params.utteranc] enable = true repo = \u0026#34;prime167/BlogComment\u0026#34; issueTerm = \u0026#34;title\u0026#34; theme = \u0026#34;github-light\u0026#34; 添加新文章 运行\n1 hugo new post/hello-world.md 文件就会生成到 content\\post\\hello-world.md\n编辑 用vscode打开myBlog文件夹，编辑hell-world.md\n1 2 3 4 5 6 7 --- title: \u0026#34;Hello World\u0026#34; date: 2019-08-07T16:26:41+08:00 lastmod: 2020-06-16T07:26:41+08:00 draft: false --- 文章的开头，在两个---之间的叫front matter，控制文章的标题，发布时间、最后修改时间等元数据。在下面接着用markdown写正文就可以了 设置tag 1 2 3 4 5 6 --- title: \u0026#34;Hello World\u0026#34; date: 2019-08-07T16:26:41+08:00 draft: true tags: [\u0026#34;git\u0026#34;,\u0026#34;git worktree\u0026#34;, \u0026#34;scm\u0026#34;] --- 设置分类 1 2 3 4 5 6 7 --- title: \u0026#34;git worktree 命令的使用\u0026#34; date: 2019-07-26T14:05:29+08:00 draft: false tags: [\u0026#34;git\u0026#34;,\u0026#34;git worktree\u0026#34;, \u0026#34;scm\u0026#34;] categories: [\u0026#34;技术\u0026#34;] --- 设置文章摘要 hugo 默认把文章的前70个字符作为摘要，有时候会断的莫名其妙，可以在正文任意位置插入*\u0026lt;!--more--\u0026gt;* ,之前的是摘要，之后的是正文。\n本地预览 运行\n1 hugo server -D 浏览器打开 localhost:1313, 就可以预览了，保存后就实时更新。编辑时使用vscode的实时预览，保存后在浏览器中预览。如果显示器足够大或者双屏，就可以都开着。\n发布 文章写完检查无误后，把 draft:true 改成 draft:false，命令行预先hugo,生成静态页面到public文件。把这个文件夹push到一开始创建的GitHub repo，文章就发布了。\n","permalink":"http://prime167.github.io/posts/2019-11-25-hugo-setup/","summary":"\u003cp\u003e新博客配置的七七八八了，记录一下过程和未解决问题。\u003c/p\u003e","title":"Hugo 配置记录"},{"content":"看似简单的问题，背后涉及了很多基础知识。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 using System; namespace Cs1612Demo { class Program { static void Main(string[] args) { Player p = new Player(); p.ShowLocation(); p.Location.x = 1; // property return temp value =\u0026gt; CS1612 p._location.x = 2; // filed is ok p.ShowLocation(); List\u0026lt;Point\u0026gt; _locations = new List\u0026lt;Point\u0026gt;(); _locations[0].x = 3;// List indexer is just a property, and property return temp value =\u0026gt; CS1612CS1612 Point[] _locationsArray = new Point[]{new Point()}; _locationsArray[0].x = 3; // array index return reference, ok } } struct Point { public float x; public float y; } class Player { public Point Location { get { return _location;} set { _location = value; } } public Point _location = new Point(); public void ShowLocation() { Console.WriteLine(Location.x + \u0026#34;,\u0026#34; + Location.y); } } } 分析 上面的代码不会通过编译，错误为：\n1 2 错误 CS1612 无法修改“Player.Location”的返回值，因为它不是变量* 错误 CS1612 无法修改“List\u0026lt;Point\u0026gt;.this[init]”的返回值，因为它不是变量* 属性的get方法返回值类型，而不是Location的引用，由于Point是值类型，索引返回Location的副本。由于这个副本不保存在任何变量中，所以修改值并不会保存回Location变量，赋值没有意义。 字段是直接在原值上操作 List的索引器是一个属性，同上 1 2 3 4 5 6 7 8 9 10 11 12 public T this[int index] { get { return _items[index]; } set { _items[index] = value; } } CLR 从一开始就支持数组，数组的索引返回引用，类似field，是在原值上直接操作 消除错误的方法：\n将Point改为class。但由于Point是 C#的内置类型，这种方法并大多数情况下并不可行。\n去掉 *{ get; set; } *将Location 改为public field，这也不推荐。Property较之Field有很多优点\n封装底层field set中可以包含验证逻辑 field不能用于绑定 如前所述，return _location返回的是一个临时副本，对其修改没意义。那我们就先把它赋给一个变量，修改后再赋回去：\n1 2 3 4 5 6 7 8 9 10 //p.Location.x = 6; // 报错 CS1612 //p.Location.y = 2; // 报错 CS1612 var location = p.Location; location.x = 6; location.y = 2; p.Location = location; var temp = _locations[0]; temp.x = 3; _locations[0] = temp; 有的struct很大，为了避免按值传递带来的性能损耗，C# 7.0新增了ref returns，允许开发者返回值类型的引用，并直接对其修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 using System; namespace Cs1612Demo { class Program { static void Main(string[] args) { Player p = new Player(); p.ShowLocation(); p.Location.x = 6; p.Location.y = 2; p.ShowLocation(); } } struct Point { public float x; public float y; } class Player { Point _location; public ref Point Location { get { return ref _location; } } public void ShowLocation() { Console.WriteLine(Location.x + \u0026#34;,\u0026#34; + Location.y); } } 这样，返回的就是_location 的引用，可以像上面改成class一样修改了。注意这里需要去掉setter，否则会报错误\u0026quot; CS8147 按引用返回的属性不能有 set 访问器 \u0026ldquo;。因为返回的是引用，可以任意修改，也就没有必要保留set访问器了。\n参考链接 Compiler Error CS1612\nRef returns and ref locals\nWhat\u0026rsquo;s new in C# 7.0\nC# 7 Series, Part 7: Ref Returns\nPerformance traps of ref locals and ref returns in C# https://stackoverflow.com/a/6705630/65994\n","permalink":"http://prime167.github.io/posts/2019-07-30-csharp-error-cs1612/","summary":"\u003cp\u003e看似简单的问题，背后涉及了很多基础知识。\u003c/p\u003e","title":"C# 编译错误 CS1612：无法修改“xxx”的返回值，因为它不是变量"},{"content":"寓言一则\n从前，有一个农夫扛着铲子走在路上，碰到一个坑，虽然他一步就可以跨过去，但是他想“万一小孩子一脚踩进去摔倒了就不好了”。于是他从路边的田里弄了些土，仔细把坑填好、夯实，抹平，好像没有过坑一样，心里美滋滋的继续往前走。\n第二天，又一个农夫扛着铲子走在路上，碰到一个坑，这个坑太大了，大的他跳都跳不过去。于是他从身后的路上挖些土把前面的坑填平，自己继续往前走，留下身后坑坑洼洼的路。\n第三天，又一个农夫扛着铲子走在路上，碰到一个坑，这个坑太大、太深了。他就从他脚下挖土往里填，填了三天三夜终于把坑填上了，抬头一看，自己在一个巨坑的底部，再也不出去了。\n","permalink":"http://prime167.github.io/posts/2019-07-26-about-fix-bugs/","summary":"\u003cp\u003e寓言一则\u003c/p\u003e","title":"关于填坑"},{"content":"使用 git worktree 同时 签出多个分支，提高开发效率，节省磁盘空间。\n概念 git 最强大也最为人称道的就是它的分支功能，现在也有了很多成熟的分支模型，比如常用的master/dev/feature/hotfix 模型。\n正常情况下，我们用 git init 或者 git clone 命令 新建一个repo，目录内有一个 .git文件夹 和我们要跟踪的文件，该目录就是我们的 工作目录 working directory ，也就是 working tree 。我们要切换分支时，就用 checkout 命令：\n1 git checkout hotfix-2 但是随着时间的推移，我们的repo越来越庞大，切换分支变得越来昂贵：\ngit checkout 命令本身需要处理很多的文件，导致很大的磁盘IO开销 IDE 需要重新索引项目文件，特别是两个分支之间差别很大时。 跑耗时的单元测试，无法切换分支，只能等着。 虽然我们也可以通过克隆多份，每一份checkout不同的分支的方式来解决上面列出的问题，但这会引入新的问题：\n占用较多的磁盘空间，因为每一份克隆都有一个.git 文件夹。 为了保持多个克隆间的同步，需要在不同的文件夹拉取相同的变更很多次。 针对这些问题，git在2.5 版中加入了 worktree 子命令,这样就可以把一个或多个分支checkout到单独的文件夹，但这些文件夹是关联到现有的版本库的，他们共享一个.git 文件夹。\n使用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 先初始化一个 repo mkdir projectX cd projectX touch readme.md git init git add . git commit -m init git remote add origin https://github.com/prime167/projectX.git git push # 初始化 dev 分支 git checkout -b dev touch a.cs git add . git commit -m \u0026#34;add a.cs\u0026#34; git push # 从现有本地分支新建一个worktree git checkout master git worktree add ../projectX-dev dev # 从现有tag新建一个worktree git worktree add ../projectX-v0.1 v0.1 #从现有远程分支新建一个worktree git fetch git worktree add ../projectX-hotfix1 hotfix1 # 新建分支并添加worktree，最后的master为基础commit-ish，如果不指定，则默认为HEAD git worktree add -b feature-A ../projectX-feature-A master #列出worktree git worktree list # 移动worktree (git 2.17 新增) git worktree move ../projectX-feature-hotfix2 ../projectX-hotfix2 # 删除worktree的话，直接删除目录即可 rm -rf ../projectX-hotfix2 git worktree prune 技术细节 以 git worktree add ../projectX-dev dev 为例：\n在版本库的 .git/worktrees 下新建一个目录projectX-Dev, gitdir 文件指向worktree内的 .git 文件\n1 D:/git/projectX-dev/.git 新建一个与ProjectX平级的的projectX目录，包括dev分支的内容和一个 .git 文件，内容为\n1 gitdir: D:/git/projectX/.git/worktrees/projectX-dev git worktree move ../projectX-Dev ../projectX-Dev1 命令只会更改 gitdir 的内容到新位置，其目录名并不会更改；相应的，worktree内的 .git 文件的内容也不会更改。所以以后手动改了worktree的目录名后，如果没有强迫症的话只改 gitdir 的内容就可以了。\n限制 一个分支不能同时迁出到多个worktree 对子模块的支持不完整 总结 本篇，我们学习了使用 worktree 进行多分枝并行开发的方法和优点，包括但不限于：\n可以快速进行多分枝并行开发、测试 提交可以在同一个repo中共享 和再次克隆项目相比，节省了硬盘空间 方便分支间的比较和文件操作 避免忘记切换分支造成的拷错 dll或者exe的尴尬。 参考链接 git-worktree - Manage multiple working trees 2.Git 2.5, including multiple worktrees and triangular workflows\n","permalink":"http://prime167.github.io/posts/2019-07-26-git-worktree-usage/","summary":"\u003cp\u003e使用 git worktree \u003cstrong\u003e同时\u003c/strong\u003e 签出多个分支，提高开发效率，节省磁盘空间。\u003c/p\u003e","title":"git worktree 命令的使用"},{"content":"公司主要是用WinCE6.0做嵌入式开发，有时需要把文件发送到PC机器，但最近有一台1803的Win10总是报\u0026quot;error 53 找不到网络路径\u0026quot;的错误。\n解决过程：\nTCP/IP NetBIOS Helper 服务已开启 网卡属性里的 “Microsoft 网络客户端” 存在并勾选 网卡属性里的 “Microsoft 网络的文件和打印机共享” 存在并勾选 最后定位到原因：SMB 1.0/CIFS 共享文件支持功能没有开启，这是一很老的网络共享协议，漏洞很多，默认是关闭的。\n","permalink":"http://prime167.github.io/posts/2019-07-11-fix-windows10-share/","summary":"\u003cp\u003e公司主要是用WinCE6.0做嵌入式开发，有时需要把文件发送到PC机器，但最近有一台1803的Win10总是报\u0026quot;error 53 找不到网络路径\u0026quot;的错误。\u003c/p\u003e","title":"解决WinCE6.0无法访问Win10共享文件夹问题"},{"content":"新博客开张。\n博客也开了不少了，从最开始的 Windows Live Spaces 到blogspot、wordpress、CSDN、blogcn。希望这次能够坚持下来，不求每天都写，但求每一篇都言之有物。\n本博客是托管在Github Pages上的静态页面，生成引擎用的是golang写的hugo，配置还在不断完善，下一篇写一些配置过程 我是一个程序员，主要使用C#语言，所以这个博客的内容会以编程为主，还有读书和跑步。\n","permalink":"http://prime167.github.io/posts/2019-07-10-hello-world/","summary":"\u003cp\u003e新博客开张。\u003c/p\u003e","title":"Hello World"}]